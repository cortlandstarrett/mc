-- BP 7.1.6 content: Package syschar: 3 persistence-version: 7.1.6

INSERT INTO EP_PKG
	VALUES ("92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	"d9bc5487-4193-4817-be1c-6c3f3339aebf",
	'afun',
	'',
	0);
INSERT INTO GD_MD
	VALUES ("6973670d-3d7c-4fac-89ff-4f91fe58cfa0",
	112,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	108,
	0,
	0,
	1,
	1,
	1,
	12,
	1,
	0,
	0,
	0,
	0,
	0,
	'4.0.0',
	'escher::mcmc::afun');
INSERT INTO DIM_DIA
	VALUES ("6973670d-3d7c-4fac-89ff-4f91fe58cfa0",
	'',
	1.000000,
	4000.000000,
	3000.000000,
	"00000000-0000-0000-0000-000000000000");
INSERT INTO S_SYNC
	VALUES ("9ed9dc0f-cf53-408f-8d78-5c9c2b0847ac",
	"00000000-0000-0000-0000-000000000000",
	'a0',
	'',
	'::parm_sort();
::rel_pseudoformalize();
::sys_singletons();

// These are markings that are for the model-based MC.
select any stringpointer_s_dt from instances of S_DT where ( selected.Name == "stringpointer" );
if ( not_empty stringpointer_s_dt )
  select many o_attrs from instances of O_ATTR where ( ( selected.Name == "Action_Semantics_internal" ) or ( selected.Name == "Descrip" ) );
  for each o_attr in o_attrs
    select one s_dt related by o_attr->S_DT[R114];
    unrelate o_attr from s_dt across R114;
    // o_attr.DT_ID = 00
    relate o_attr to stringpointer_s_dt across R114;
    // o_attr.DT_ID = s_dt.DT_ID
  end for;
  ::MapDataTypeAsPointer( component_name:"*", dt_name:"stringpointer", pointer_type:"c_t", include_file:"" );
end if;

::sys_populate();

select any te_sys from instances of TE_SYS;
::sys_analyze( te_sys:te_sys );
::CreateSpecialWhereClauseInstances( te_sys:te_sys );

select many te_cs from instances of TE_C where ( selected.included_in_build );
for each te_c in te_cs
  // Propagate domain information to the system level.
  ::te_c_CollectLimits( te_c:te_c );
  select many te_classs related by te_c->TE_CLASS[R2064] where ( not selected.ExcludeFromGen );
  c = ::class_sort( te_classs:te_classs );
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO PE_PE
	VALUES ("9ed9dc0f-cf53-408f-8d78-5c9c2b0847ac",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("82c46415-fad5-4b15-a3f1-73a4f8638be0",
	"00000000-0000-0000-0000-000000000000",
	'AutoInitializeUniqueIDs',
	'',
	'//============================================================================
// $RCSfile: frag_util.arc,v $
//
// Description:
// This archetype file provides general purpose functions used during 
// action language translation. They are not specific to any particular
// fragment generator entry points.
//============================================================================
//
//============================================================================
// Initialize the attributes of type unique_id that are identifiers
// and therefore need to be automatically set up at create time.
//============================================================================
te_class = param.te_class;
instance = param.instance;
//
::oal( s:"T_clear();" );
select any te_file from instances of TE_FILE;
select any te_instance from instances of TE_INSTANCE;
select any te_string from instances of TE_STRING;
select any te_sys from instances of TE_SYS;
// Be sure we have the first attribute in the class.
select any first_te_attr related by te_class->TE_ATTR[R2061];
while ( not_empty first_te_attr )
  select one prev_te_attr related by first_te_attr->TE_ATTR[R2087.''succeeds''];
  if ( empty prev_te_attr )
    break;
  end if;
  first_te_attr = prev_te_attr;
end while;
te_attr = first_te_attr;
while ( not_empty te_attr )
  select one o_attr related by te_attr->O_ATTR[R2033];
  if ( te_attr.translate )
    r = ::GetAttributeCodeGenType( o_attr:o_attr );
    te_dt = r;
    not_empty_o_oida = false;
    if ( not_empty te_dt )
      if ( 5 == te_dt.Core_Typ )
        select any o_oida related by o_attr->O_OIDA[R105];
        if ( not_empty o_oida )
          not_empty_o_oida = true;
        end if;
      end if;
      T::include(file:"c/t.class.attribute.init.c");
    end if;
  end if;
  //
  // Advance to the next object attribute, if any.
  select one te_attr related by te_attr->TE_ATTR[R2087.''precedes''];
end while;
return T::body();
',
	"ba5eda7a-def5-0000-0000-000000000004",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("aaa0b436-94cc-4e08-9e87-f98dbebfd7a7",
	"82c46415-fad5-4b15-a3f1-73a4f8638be0",
	'te_class',
	"a4c72a7c-2bdb-49fd-8096-759f23d860e2",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("a4c72a7c-2bdb-49fd-8096-759f23d860e2",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Extended Class>',
	'',
	'',
	'../../ooaofooa/Translation Extensions/Translation Extensions.xtuml');
INSERT INTO S_SPARM
	VALUES ("6a23e956-6688-4c21-88ac-a42d55a9df25",
	"82c46415-fad5-4b15-a3f1-73a4f8638be0",
	'instance',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"aaa0b436-94cc-4e08-9e87-f98dbebfd7a7",
	'');
INSERT INTO PE_PE
	VALUES ("82c46415-fad5-4b15-a3f1-73a4f8638be0",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("b76d99c4-33bf-4dbc-b706-563ec037c811",
	"00000000-0000-0000-0000-000000000000",
	'ExpandNonOptimizedSpecialWhereComparison',
	'',
	'//
//============================================================================
o_obj = param.o_obj;
special = param.special;
selected_var_name = param.selected_var_name;
//
compare_stmt = "";
if ( special )
  select any te_instance from instances of TE_INSTANCE;
  select any te_string from instances of TE_STRING;
  compare_stmt = "";
  cmp_element = "";
  select one te_class related by o_obj->TE_CLASS[R2019];
  // Be sure we have the first attribute in the class.
  select any first_te_attr related by te_class->TE_ATTR[R2061];
  while ( not_empty first_te_attr )
    select one prev_te_attr related by first_te_attr->TE_ATTR[R2087.''succeeds''];
    if ( empty prev_te_attr )
      break;
    end if;
    first_te_attr = prev_te_attr;
  end while;
  te_attr = first_te_attr;
  while ( not_empty te_attr )
    //.if ( 4 == te_attr.Core_Typ )
    if ( 4 == 4 )
      cmp_element = "!${te_instance.module}${te_string.strcmp}(${selected_var_name}->${te_attr.GeneratedName}, ${te_attr.ParamBuffer})";
    else
      cmp_element = "${selected_var_name}->${te_attr.GeneratedName} == ${te_attr.ParamBuffer}";
    end if;
    compare_stmt = compare_stmt + cmp_element;
    // Advance to the next object attribute, if any.
    select one te_attr related by te_attr->TE_ATTR[R2087.''precedes''];
    if ( not_empty te_attr )
      compare_stmt = compare_stmt + " && ";
    end if;
  end while;
end if;
return compare_stmt;
',
	"ba5eda7a-def5-0000-0000-000000000004",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("509d57ec-6b62-4ab3-b346-2f1007a3d79c",
	"b76d99c4-33bf-4dbc-b706-563ec037c811",
	'o_obj',
	"63f4ff99-f127-443b-a678-30ace41da702",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("63f4ff99-f127-443b-a678-30ace41da702",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Model Class>',
	'',
	'',
	'../../ooaofooa/Instance Reference Data Types/Instance Reference Data Types.xtuml');
INSERT INTO S_SPARM
	VALUES ("c73eff6f-78f9-4fbf-84c8-dc810d179197",
	"b76d99c4-33bf-4dbc-b706-563ec037c811",
	'special',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'',
	"509d57ec-6b62-4ab3-b346-2f1007a3d79c",
	'');
INSERT INTO S_SPARM
	VALUES ("eddcaf2e-5910-4f18-8f8e-c81276b984ed",
	"b76d99c4-33bf-4dbc-b706-563ec037c811",
	'selected_var_name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"c73eff6f-78f9-4fbf-84c8-dc810d179197",
	'');
INSERT INTO PE_PE
	VALUES ("b76d99c4-33bf-4dbc-b706-563ec037c811",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("9314b9d0-c623-463f-bc4c-97c37f0bfb63",
	"00000000-0000-0000-0000-000000000000",
	'CreateSpecialWhereComparisonArguments',
	'',
	'//
//============================================================================
te_class = param.te_class;
o_id = param.o_id;
//
select many o_attrs related by o_id->O_OIDA[R105]->O_ATTR[R105];
num_ident_attr = cardinality o_attrs;
//
param_list = "";
oida_count = 0;
//
// Be sure we have the first attribute in the class.
select any first_te_attr related by te_class->TE_ATTR[R2061];
while ( not_empty first_te_attr )
  select one prev_te_attr related by first_te_attr->TE_ATTR[R2087.''succeeds''];
  if ( empty prev_te_attr )
    break;
  end if;
  first_te_attr = prev_te_attr;
end while;
te_attr = first_te_attr;
while ( not_empty te_attr )
  if ( te_attr.Included )
    oida_count = oida_count + 1;
    param_list = param_list + te_attr.ParamBuffer;
    if ( oida_count < num_ident_attr )
      param_list = param_list + ", ";
    end if;
  end if;
  select one te_attr related by te_attr->TE_ATTR[R2087.''precedes''];
end while;
//
return param_list;
',
	"ba5eda7a-def5-0000-0000-000000000004",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("b022b208-7c20-4f0f-a7aa-0d217c30d34e",
	"9314b9d0-c623-463f-bc4c-97c37f0bfb63",
	'te_class',
	"a4c72a7c-2bdb-49fd-8096-759f23d860e2",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("931a9ec1-1b0c-4143-afac-46ed9100d64f",
	"9314b9d0-c623-463f-bc4c-97c37f0bfb63",
	'o_id',
	"ffd7219f-5715-4156-83cf-5621fd752f90",
	0,
	'',
	"b022b208-7c20-4f0f-a7aa-0d217c30d34e",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("ffd7219f-5715-4156-83cf-5621fd752f90",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Class Identifier>',
	'',
	'',
	'../../ooaofooa/Subsystem/Subsystem.xtuml');
INSERT INTO PE_PE
	VALUES ("9314b9d0-c623-463f-bc4c-97c37f0bfb63",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("82c1252b-6371-4628-bfe8-b2f5ec544bd4",
	"00000000-0000-0000-0000-000000000000",
	'oal',
	'',
	'//
s = param.s;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("89f3ca95-f2dc-458a-9f20-5390ee8a2f04",
	"82c1252b-6371-4628-bfe8-b2f5ec544bd4",
	's',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("82c1252b-6371-4628-bfe8-b2f5ec544bd4",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("be7d74dc-9a61-4407-94bc-1c4370179c4b",
	"00000000-0000-0000-0000-000000000000",
	'GetBaseTypeForUDT',
	'',
	'//============================================================================
// Recursively locate the datatype at the base of the UDT type definition 
// chain. Traverses up through UDTs based on UDTs until we find the underlying
// S_DT instance (which may actually be EDT, SDT, IRDT or CDT).
//============================================================================
s_udt = param.s_udt;
select one s_dt related by s_udt->S_DT[R18];
select one s_udt related by s_dt->S_UDT[R17];
if ( not_empty s_udt )
  r = ::GetBaseTypeForUDT( s_udt:s_udt );
  s_dt = r;
end if;
return s_dt;
',
	"4a90cd45-ece0-4e72-afe7-44996f9d7e1e",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("8ed813d5-978c-4b38-9fad-7281c9037c54",
	"be7d74dc-9a61-4407-94bc-1c4370179c4b",
	's_udt',
	"587d8963-4757-4426-bc18-b235bcbd7937",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("587d8963-4757-4426-bc18-b235bcbd7937",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<User Data Type>',
	'',
	'',
	'../../ooaofooa/Domain/Domain.xtuml');
INSERT INTO PE_PE
	VALUES ("be7d74dc-9a61-4407-94bc-1c4370179c4b",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_DT_PROXY
	VALUES ("4a90cd45-ece0-4e72-afe7-44996f9d7e1e",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Data Type>',
	'',
	'',
	'../../ooaofooa/Instance Reference Data Types/Instance Reference Data Types.xtuml');
INSERT INTO S_SYNC
	VALUES ("353eb6f8-c6da-4e63-a17b-db52139b497d",
	"00000000-0000-0000-0000-000000000000",
	'GetAttributeCodeGenType',
	'',
	'//
//============================================================================
//   Get the S_DT and S_CDT object references for a given attribute
//   (O_ATTR) instance.
//============================================================================
o_attr = param.o_attr;
//
select one s_dt related by o_attr->S_DT[R114];
select one s_udt related by s_dt->S_UDT[R17];
if ( not_empty s_udt )
  r = ::GetBaseTypeForUDT( s_udt:s_udt );
  s_dt = r;
end if;
select one te_dt related by s_dt->TE_DT[R2021];
select one s_cdt related by s_dt->S_CDT[R17];
//
if ( empty s_cdt )
  select one s_edt related by s_dt->S_EDT[R17];
  if ( empty s_edt )
    select one s_sdt related by s_dt->S_SDT[R17];
    if ( empty s_sdt )
      select one s_irdt related by s_dt->S_IRDT[R17];
      if ( empty s_irdt )
        T::print(s:"Error in attribute ${o_attr.Name}");
        T::print(s:"with data type ${s_dt.Name}");
        T::exit(i:100);
      end if;
    end if;
  else
    // Enum, use integer type.
    // CDS Some day we should pass along the enumeration type.
    select any s_cdt from instances of S_CDT where ( selected.Core_Typ == 2 );
  end if;
end if;
//
if ( not_empty s_cdt )
  if ( 7 == s_cdt.Core_Typ )
    // s_cdt.Core_Typ is "same_as<Base_Attribute>"
    select one base_o_attr related by o_attr->O_RATTR[R106]->O_BATTR[R113]->O_ATTR[R106];
    if ( empty base_o_attr )
      select one o_obj related by o_attr->O_OBJ[R102];
      T::print(s:"\nCould not find O_BATTR for object ${o_obj.Name} (${o_obj.Key_Lett}) attribute ${o_attr.Name} !");
      T::print(s:"\nDid you combine a referential and then rename the combined attribute?");
      T::exit(i:101);
    end if;
    // Note: the following is a recursive call to this function
    r = ::GetAttributeCodeGenType( o_attr:base_o_attr );
    te_dt = r;
  end if;
end if;
return te_dt;
',
	"b38f65e4-3751-44ac-a43f-142a02d52c3a",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("3bb6b7d5-7636-4832-9021-dfcad3901c28",
	"353eb6f8-c6da-4e63-a17b-db52139b497d",
	'o_attr',
	"579b8247-e153-481d-8926-384cdc722464",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("579b8247-e153-481d-8926-384cdc722464",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Attribute>',
	'',
	'',
	'../../ooaofooa/Instance Reference Data Types/Instance Reference Data Types.xtuml');
INSERT INTO PE_PE
	VALUES ("353eb6f8-c6da-4e63-a17b-db52139b497d",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_DT_PROXY
	VALUES ("b38f65e4-3751-44ac-a43f-142a02d52c3a",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Extended Data Type>',
	'',
	'',
	'../../ooaofooa/Translation Extensions/Translation Extensions.xtuml');
INSERT INTO S_SYNC
	VALUES ("cd94de22-dd82-4d3a-8a67-f3f9272a89fd",
	"00000000-0000-0000-0000-000000000000",
	'MapUserSpecifiedDataTypePrecision',
	'',
	'//
//============================================================================
// Map a user defined data types precision into its corresponding instance
// of Data Type (S_DT).
// Note:  Might prefer POSIX type support here, but doubt we can count
// on most embedded targets thinking this way.  Thus brute force the types.
//============================================================================
te_dt = param.te_dt;
mapping = param.mapping;
error = false;
type = mapping;
if ( ( type == "uchar_t" ) or ( ( type == "u_char" ) or ( type == "unsignedchar" ) ) )
  te_dt.ExtName = "unsigned char";
elif ( ( type == "char_t" ) or ( type == "char" ) )
  te_dt.ExtName = "char";
elif ( type == "signedchar" )
  te_dt.ExtName = "signed char";
elif ( ( type == "ushort_t" ) or ( ( type == "u_short" ) or ( type == "unsignedshort" ) ) )
  te_dt.ExtName = "unsigned short";
elif ( ( type == "short_t" ) or ( type == "short" ) )
  te_dt.ExtName = "short";
elif ( type == "signedshort" )
  te_dt.ExtName = "signed short";
elif ( ( type == "uint_t" ) or ( ( type == "u_int" ) or ( type == "unsignedint" ) ) )
  te_dt.ExtName = "unsigned int";
elif ( type == "s1_t" )
  te_dt.ExtName = "s1_t";
elif ( type == "u1_t" )
  te_dt.ExtName = "u1_t";
elif ( type == "s2_t" )
  te_dt.ExtName = "s2_t";
elif ( type == "u2_t" )
  te_dt.ExtName = "u2_t";
elif ( type == "s4_t" )
  te_dt.ExtName = "s4_t";
elif ( type == "u4_t" )
  te_dt.ExtName = "u4_t";
elif ( type == "i_t" )
  te_dt.ExtName = "i_t";
elif ( ( type == "int_t" ) or ( type == "int" ) )
  te_dt.ExtName = "int";
elif ( type == "signedint" )
  te_dt.ExtName = "signed int";
elif ( ( type == "ulong_t" ) or ( ( type == "u_long" ) or ( type == "unsignedlong" ) ) )
  te_dt.ExtName = "unsigned long";
elif ( ( type == "long_t" ) or ( type == "long" ) )
  te_dt.ExtName = "long";
elif ( type == "signedlong" )
  te_dt.ExtName = "signed long";
elif ( ( type == "u_longlong_t" ) or ( ( type == "u_longlong_t" ) or ( type == "unsignedlonglong" ) ) )
  te_dt.ExtName = "unsigned long long";
elif ( ( type == "longlong_t" ) or ( ( type == "longlong" ) or ( type == "signedlonglong" ) ) )
  te_dt.ExtName = "long long";
  //
elif ( type == "float" )
  te_dt.ExtName = "float";
elif ( type == "r4_t" )
  te_dt.ExtName = "r4_t";
elif ( type == "double" )
  te_dt.ExtName = "double";
elif ( type == "r8_t" )
  te_dt.ExtName = "r8_t";
  //
elif ( type == "size_t" )
  te_dt.ExtName = "size_t";
elif ( type == "ssize_t" )
  te_dt.ExtName = "ssize_t";
elif ( type == "time_t" )
  te_dt.ExtName = "time_t";
elif ( type == "clock_t" )
  te_dt.ExtName = "clock_t";
elif ( type == "volatile_clock_t" )
  te_dt.ExtName = "volatile unsigned long";
  //
else
  error = true;
end if;
return error;
',
	"ba5eda7a-def5-0000-0000-000000000001",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("452a8e52-f00c-4f3a-939d-61630ad99bc8",
	"cd94de22-dd82-4d3a-8a67-f3f9272a89fd",
	'te_dt',
	"b38f65e4-3751-44ac-a43f-142a02d52c3a",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("f4564916-6756-44bf-970b-878d3b82a549",
	"cd94de22-dd82-4d3a-8a67-f3f9272a89fd",
	'mapping',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"452a8e52-f00c-4f3a-939d-61630ad99bc8",
	'');
INSERT INTO PE_PE
	VALUES ("cd94de22-dd82-4d3a-8a67-f3f9272a89fd",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("3e09c599-a009-4465-939a-8cfeb2089914",
	"00000000-0000-0000-0000-000000000000",
	'UserSuppliedDataTypeIncludes',
	'',
	'//
// Return the structure type for persistent links.
select any te_file from instances of TE_FILE;
sys_types_file_name = ( te_file.types + "." ) + te_file.hdr_file_ext;
select many special_te_dts from instances of TE_DT where ( ( selected.Include_File != "" ) and ( selected.Include_File != sys_types_file_name ) );
s = "";
for each special_te_dt in special_te_dts
  s = ( s + "#include " ) + ( special_te_dt.Include_File + "\n" );
  ::oal( s:"s = Escher_strcpy( s, Escher_stradd( Escher_stradd( s, #include  ), Escher_stradd( special_te_dt->Include_File, \n ) ) ); // Ccode" );
end for;
return s;
',
	"ba5eda7a-def5-0000-0000-000000000004",
	1,
	'');
INSERT INTO PE_PE
	VALUES ("3e09c599-a009-4465-939a-8cfeb2089914",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("74b6f35d-c8d3-42bf-8ad6-4a68cd078a20",
	"00000000-0000-0000-0000-000000000000",
	'sys_analyze',
	'',
	'//============================================================================
// This query file provides the "first pass" of a multi-pass translation
// model compiler.  The first pass analyzes the action semantics embodied
// in the analysis domain, and applies optimization algorithms to the
// action language statements encountered.  The results of these algorithmic
// operations are then leveraged by subsequent passes of the structural
// queries and templates to realize time/space/performance trade offs in
// the generated application code.
//============================================================================
//
//
te_sys = param.te_sys;
T::print(s:"Analyzing model and making optimizations....");
// Identify state models having at least one state, event and transition.
::SM_SM_mark_valid();
// Count up how many times each event is created/generated.
::event_smt_used();
// Find classes that are created in some way and identify invalid creates.
::class_smt_created();
// Detect invalid deletions.
::class_smt_deleted();
// Track down optimizable where clauses.
::selection_whereclause_identify_special();
// Identify the associations that need link and/or unlink methods.
::association_mark_link_unlink_needed();
// Identify associations that are navigated (in either or both directions).
::association_R_OIR_mark_navigated();
// Find which event queues are necessary.
::event_queue_analyze_needed();
::attr_analyze_accesses();
//.invoke attr_analyze_codegen( te_sys )
::TE_TXN_used();
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("8fe5600f-107a-4f51-b858-da71a2f9fc5c",
	"74b6f35d-c8d3-42bf-8ad6-4a68cd078a20",
	'te_sys',
	"9c3c2949-6ecb-4cf4-9013-792d37160584",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("9c3c2949-6ecb-4cf4-9013-792d37160584",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Extended System>',
	'',
	'',
	'../../ooaofooa/Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("74b6f35d-c8d3-42bf-8ad6-4a68cd078a20",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("6bbe2738-9760-4778-9459-fb24626637bf",
	"00000000-0000-0000-0000-000000000000",
	'te_c_CollectLimits',
	'',
	'//============================================================================
// These queries collect static analysis information and propagate it
// forward to the system build step by outputting a set of INSERT
// statements that will populate the system build gen database.
//============================================================================
//
//
//============================================================================
// Store statistics into TE_C.
//============================================================================
te_c = param.te_c;
//
select any te_file from instances of TE_FILE;
//
// Analyze maximums for extents.
// The extents should be analyzed only *after* extent size coloring!
select many te_classs related by te_c->TE_CLASS[R2064] where ( not selected.ExcludeFromGen );
object_class_extents = 0;
relationship_extents = 0;
largest_object_extent = 0;
//
for each te_class in te_classs
  select one o_obj related by te_class->O_OBJ[R2019];
  object_class_extents = object_class_extents + te_class.MaxExtentSize;
  if ( te_class.MaxExtentSize > largest_object_extent )
    largest_object_extent = te_class.MaxExtentSize;
  end if;
  // Calculate maximum extents required for objects on "MANY" side of a relationship.
  select many r_rgos related by o_obj->R_OIR[R201]->R_RGO[R203] where ( selected.Obj_ID == o_obj.Obj_ID );
  for each r_rgo in r_rgos
    select one form related by r_rgo->R_FORM[R205];
    if ( not_empty form )
      if ( form.Mult == 1 )
        relationship_extents = relationship_extents + te_class.MaxExtentSize;
      end if;
    end if;
    select one assr related by r_rgo->R_ASSR[R205];
    if ( not_empty assr )
      if ( assr.Mult == 1 )
        relationship_extents = relationship_extents + te_class.MaxExtentSize;
      end if;
    end if;
  end for;
  select many r_rtos related by o_obj->R_OIR[R201]->R_RTO[R203] where ( selected.Obj_ID == o_obj.Obj_ID );
  for each r_rto in r_rtos
    select one aone related by r_rto->R_AONE[R204];
    if ( not_empty aone )
      if ( aone.Mult == 1 )
        relationship_extents = relationship_extents + te_class.MaxExtentSize;
      end if;
    end if;
    select one aoth related by r_rto->R_AOTH[R204];
    if ( not_empty aoth )
      if ( aoth.Mult == 1 )
        relationship_extents = relationship_extents + te_class.MaxExtentSize;
      end if;
    end if;
  end for;
end for;
//
// analyze timers events selects
r = ::timer_analyze_starts();
total_timer_starts = r;
//
// Count up the event specification statements which is the supertype
// of generated and deferred events.  This will give us a starting point
// on allocating event queue resources.
// CDS - We are (re)counting the events for each component, but this code is not component-specific.
// CDS - The event counts should be "harvested" while processing the action language.
max_events = 0;
max_self_events = 0;
max_nonself_events = 0;
select many act_acts from instances of ACT_ACT;
for each act_act in act_acts
  select many event_specification_statements related by act_act->ACT_BLK[R601]->ACT_SMT[R602]->E_ESS[R603];
  all_events_count = cardinality event_specification_statements;
  select many act_sgns related by act_act->ACT_BLK[R601]->ACT_SMT[R602]->ACT_SGN[R603];
  all_events_count = all_events_count + ( cardinality act_sgns );
  if ( all_events_count > max_events )
    max_events = all_events_count;
  end if;
  // Count up the self events in this body.
  count = 0;
  for each e_ess in event_specification_statements
    select one v_var related by e_ess->E_GES[R701]->E_GSME[R703]->E_GEN[R705]->V_VAR[R712] where ( "self" == T::l(s:selected.Name) );
    if ( not_empty v_var )
      count = count + 1;
    else
      select any v_var related by event_specification_statements->E_CES[R701]->E_CSME[R702]->E_CEI[R704]->V_VAR[R711] where ( "self" == T::l(s:selected.Name) );
      if ( not_empty v_var )
        count = count + 1;
      end if;
    end if;
  end for;
  if ( count > max_self_events )
    max_self_events = count;
  end if;
  count = all_events_count - count;
  if ( count > max_nonself_events )
    max_nonself_events = count;
  end if;
  select one te_aba related by act_act->ACT_FNB[R698]->S_SYNC[R695]->TE_SYNC[R2023]->TE_ABA[R2010];
  if ( not_empty te_aba )
    te_aba.NonSelfEventCount = count;
  end if;
end for;
//
r = ::containoid_select_many_count();
max_select_many = r;
//
// functions
select many te_syncs related by te_c->TE_SYNC[R2084] where ( ( selected.IsSafeForInterrupts ) and ( selected.XlateSemantics ) );
total_interleaved_bridges = cardinality te_syncs;
//
// Count up the priority events.
select many te_evts from instances of TE_EVT where ( selected.Priority != 0 );
total_priority_events = cardinality te_evts;
//
// Count up the classes using preexisting instances defined in data (PEIs).
select many te_classs related by te_c->TE_CLASS[R2064] where ( ( not selected.ExcludeFromGen ) and ( selected.PEIsDefinedInData ) );
pei_class_count = cardinality te_classs;
//
// Count up the persistent classes.
select many te_classs related by te_c->TE_CLASS[R2064] where ( ( not selected.ExcludeFromGen ) and ( selected.Persistent ) );
persist_class_count = cardinality te_classs;
//
te_c.MaxObjExtent = object_class_extents;
te_c.MaxRelExtent = relationship_extents;
te_c.MaxSelectExtent = max_select_many * largest_object_extent;
te_c.MaxSelfEvents = max_self_events;
te_c.MaxNonSelfEvents = max_nonself_events;
te_c.MaxPriorityEvents = total_priority_events;
te_c.MaxTimers = total_timer_starts;
te_c.InterleavedBridges = total_interleaved_bridges;
te_c.PEIClassCount = pei_class_count;
te_c.PersistentClassCount = persist_class_count;
//
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("29ddab04-3c41-46b2-8a7f-6c28db1e670e",
	"6bbe2738-9760-4778-9459-fb24626637bf",
	'te_c',
	"1a67c2f6-b8b4-421a-a4f5-d999e2cdd281",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("1a67c2f6-b8b4-421a-a4f5-d999e2cdd281",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Extended Component>',
	'',
	'',
	'../../ooaofooa/Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("6bbe2738-9760-4778-9459-fb24626637bf",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("6920f899-930e-41c8-b68f-38607eafc6a4",
	"00000000-0000-0000-0000-000000000000",
	'selection_whereclause_identify_special',
	'',
	'//============================================================================
// The query/transformations in this file analyze the action language
// of the customer model and gather statistics for use in optimized
// code generation.
//============================================================================
//
//
//
// Identify (special) where clauses that can be optimized.
//
// Select the class from which extent we are selecting.
//  Mark its identifying attributes.
// Select the blind select statements having where clauses.
// Select the values that represent the where clauses that
// are binary expressions where the operator is == or AND.
// BUG:  R676 and R677 should be unconditional on the O_OBJ side.
// Select the V_SLRs and their attributes.
// Compare the two sets.
//
select many act_fiws from instances of ACT_FIW;
for each act_fiw in act_fiws
  select one v_bin related by act_fiw->V_VAL[R610]->V_BIN[R801] where ( ( selected.Operator == "and" ) or ( selected.Operator == "==" ) );
  if ( not_empty v_bin )
    select one o_obj related by act_fiw->O_OBJ[R676];
    // Select the TE_WHEREs, because we can check to see if we have
    // already marked a special where.
    select many te_wheres related by o_obj->O_ID[R104]->TE_WHERE[R2032] where ( not selected.WhereKey );
    if ( not_empty te_wheres )
      // Clear out the included flag on all attributes of this class.
      select many te_attrs related by o_obj->O_ATTR[R102]->TE_ATTR[R2033];
      for each te_attr in te_attrs
        te_attr.Included = false;
      end for;
      // Call a routine that will recursively drill down and mark any
      // attributes compared in the where clause.
      ::where_clause_mark_selected_attributes( v_bin:v_bin );
      select many te_attrs related by o_obj->O_ATTR[R102]->TE_ATTR[R2033] where ( selected.Included );
      if ( not_empty te_attrs )
        for each te_where in te_wheres
          select many identifying_te_attrs related by te_where->O_ID[R2032]->O_OIDA[R105]->O_ATTR[R105]->TE_ATTR[R2033];
          if ( te_attrs == identifying_te_attrs )
            T::print(s:"marking SPECIAL where on ${o_obj.Key_Lett}:${o_obj.Name}");
            te_where.WhereKey = true;
          end if;
        end for;
      end if;
    end if;
  end if;
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO PE_PE
	VALUES ("6920f899-930e-41c8-b68f-38607eafc6a4",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("2eaf7230-e646-4205-961c-143b912684e0",
	"00000000-0000-0000-0000-000000000000",
	'where_clause_mark_selected_attributes',
	'',
	'//
//
// Recursively drill down into the where clause expression marking
// selected attributes along the way.
//
v_bin = param.v_bin;
if ( v_bin.Operator == "and" )
  select one left_v_val related by v_bin->V_VAL[R802];
  select one right_v_val related by v_bin->V_VAL[R803];
  select one v_bin related by left_v_val->V_BIN[R801];
  if ( not_empty v_bin )
    ::where_clause_mark_selected_attributes( v_bin:v_bin );
  end if;
  select one v_bin related by right_v_val->V_BIN[R801];
  if ( not_empty v_bin )
    ::where_clause_mark_selected_attributes( v_bin:v_bin );
  end if;
elif ( v_bin.Operator == "==" )
  select one te_attr related by v_bin->V_VAL[R802]->V_SLR[R801]->O_ATTR[R812]->TE_ATTR[R2033];
  if ( not_empty te_attr )
    te_attr.Included = true;
  end if;
  select one te_attr related by v_bin->V_VAL[R803]->V_SLR[R801]->O_ATTR[R812]->TE_ATTR[R2033];
  if ( not_empty te_attr )
    te_attr.Included = true;
  end if;
else
  // allow return
end if;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("f95b2759-91f7-45f4-8409-acc423b63649",
	"2eaf7230-e646-4205-961c-143b912684e0",
	'v_bin',
	"146d5fb3-fcd3-4deb-a49c-f516ef703827",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("146d5fb3-fcd3-4deb-a49c-f516ef703827",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Binary Operation>',
	'',
	'',
	'../../ooaofooa/Value/Value.xtuml');
INSERT INTO PE_PE
	VALUES ("2eaf7230-e646-4205-961c-143b912684e0",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("b76ed004-50f7-46be-813d-e717b6231a6e",
	"00000000-0000-0000-0000-000000000000",
	'SM_SM_mark_valid',
	'',
	'//
//
// Find valid state machines and mark them thusly.
// Such state machines have at least one each of state, event and transition.
//
// Select only the state machines that have been configured for generation.
select many te_sms from instances of TE_SM;
for each te_sm in te_sms
  select one sm_sm related by te_sm->SM_SM[R2043];
  select any sm_state related by sm_sm->SM_STATE[R501];
  if ( not_empty sm_state )
    select any sm_txn related by sm_sm->SM_TXN[R505];
    if ( not_empty sm_txn )
      select any sm_evt related by sm_sm->SM_EVT[R502];
      if ( not_empty sm_evt )
        te_sm.complete = true;
      end if;
    end if;
  end if;
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO PE_PE
	VALUES ("b76ed004-50f7-46be-813d-e717b6231a6e",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("58c4b56a-f95d-42e9-a0d0-857b3b1efe94",
	"00000000-0000-0000-0000-000000000000",
	'TE_TXN_used',
	'',
	'//
//
// Update the size of SEM cells when transition actions are present.
//
select any te_sm from instances of TE_SM where ( selected.txn_action_count > 0 );
if ( not_empty te_sm )
  select any te_typemap from instances of TE_TYPEMAP;
  te_typemap.SEM_cell_type = "u2_t";
end if;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO PE_PE
	VALUES ("58c4b56a-f95d-42e9-a0d0-857b3b1efe94",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("6dd0fb89-4e83-426a-a4a9-19728a9776a0",
	"00000000-0000-0000-0000-000000000000",
	'event_smt_used',
	'',
	'//
//
// Find and mark/count events that are used in action language.
// Even though we store the information in a count, this query
// only counts each event once.
//
select many e_gsmes from instances of E_GSME;
select many te_evts related by e_gsmes->SM_EVT[R707]->TE_EVT[R2036];
for each te_evt in te_evts
  te_evt.UsedCount = te_evt.UsedCount + 1;
  te_evt.Used = true;
end for;
select many e_csmes from instances of E_CSME;
select many te_evts related by e_csmes->SM_EVT[R706]->TE_EVT[R2036];
for each te_evt in te_evts
  te_evt.UsedCount = te_evt.UsedCount + 1;
  te_evt.Used = true;
end for;
// Mark all of the signals (inter-component class-based events) as used.
select many sm_sgevts from instances of SM_SGEVT;
select many te_evts related by sm_sgevts->SM_SEVT[R526]->SM_EVT[R525]->TE_EVT[R2036];
for each te_evt in te_evts
  te_evt.UsedCount = te_evt.UsedCount + 1;
  te_evt.Used = true;
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO PE_PE
	VALUES ("6dd0fb89-4e83-426a-a4a9-19728a9776a0",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("fa1e3113-3981-426a-930b-6be1aa769a6a",
	"00000000-0000-0000-0000-000000000000",
	'class_smt_created',
	'',
	'//
//
// Mark classes that are created synchronously (nonself) or
// asynchronously (self).
//
select many act_crs from instances of ACT_CR;
select many te_classs related by act_crs->O_OBJ[R671]->TE_CLASS[R2019];
::class_smt_crdel_check( te_classs:te_classs );
for each te_class in te_classs
  te_class.NonSelfCreated = true;
end for;
select many act_cnvs from instances of ACT_CNV;
select many te_classs related by act_cnvs->O_OBJ[R672]->TE_CLASS[R2019];
::class_smt_crdel_check( te_classs:te_classs );
for each te_class in te_classs
  te_class.NonSelfCreated = true;
end for;
// Now find any creator events to classes.
select many e_gecs from instances of E_GEC;
select many te_classs related by e_gecs->E_GSME[R705]->SM_EVT[R707]->SM_SM[R502]->SM_ISM[R517]->O_OBJ[R518]->TE_CLASS[R2019];
::class_smt_crdel_check( te_classs:te_classs );
for each te_class in te_classs
  te_class.SelfCreated = true;
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO PE_PE
	VALUES ("fa1e3113-3981-426a-930b-6be1aa769a6a",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("41c1029e-8ab6-4446-9b7e-cf067dc42a97",
	"00000000-0000-0000-0000-000000000000",
	'class_smt_deleted',
	'',
	'//
//
// Check for classes that are deleted synchronously and should not be.
//
select many act_dels from instances of ACT_DEL;
select many te_classs related by act_dels->V_VAR[R634]->V_INT[R814]->O_OBJ[R818]->TE_CLASS[R2019];
::class_smt_crdel_check( te_classs:te_classs );
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO PE_PE
	VALUES ("41c1029e-8ab6-4446-9b7e-cf067dc42a97",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("0fa968c7-5770-47b3-a61a-49ca6ea03dde",
	"00000000-0000-0000-0000-000000000000",
	'class_smt_crdel_check',
	'',
	'//
te_classs = param.te_classs;
for each te_class in te_classs
  if ( te_class.IsReadOnly )
    select one o_obj related by te_class->O_OBJ[R2019];
    T::print(s:"ERROR:  Attempt to create/delete read-only object ${o_obj.Name} (${o_obj.Key_Lett})");
  end if;
  if ( te_class.IsFixedPopulation )
    select one o_obj related by te_class->O_OBJ[R2019];
    T::print(s:"ERROR:  Attempt to create/delete object ${o_obj.Name} (${o_obj.Key_Lett}) within static instance population.");
  end if;
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("59f14e38-6f61-4601-a791-1f79873ad5be",
	"0fa968c7-5770-47b3-a61a-49ca6ea03dde",
	'te_classs',
	"f76e163a-e9e5-4b43-9fb2-aeeda16e3740",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("f76e163a-e9e5-4b43-9fb2-aeeda16e3740",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref_set<Extended Class>',
	'',
	'',
	'../../ooaofooa/Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("0fa968c7-5770-47b3-a61a-49ca6ea03dde",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("9ef57745-48d7-4c08-b631-a2a04a629e0f",
	"00000000-0000-0000-0000-000000000000",
	'event_queue_analyze_needed',
	'',
	'//
// Count up all the places that events are either generated directly (E_GEN)
// or where they are created for deferred generation (E_CEI).
// Also count up the self versus nonself events.
//
self_queue_needed = false;
nonself_queue_needed = false;
select many e_gens from instances of E_GEN;
select any v_var related by e_gens->V_VAR[R712] where ( selected.Name == "self" );
if ( not_empty v_var )
  self_queue_needed = true;
end if;
select any v_var related by e_gens->V_VAR[R712] where ( selected.Name != "self" );
if ( not_empty v_var )
  nonself_queue_needed = true;
end if;
if ( not ( self_queue_needed and nonself_queue_needed ) )
  select many e_ceis from instances of E_CEI;
  select any v_var related by e_ceis->V_VAR[R711] where ( selected.Name == "self" );
  if ( not_empty v_var )
    self_queue_needed = true;
  end if;
  select any v_var related by e_ceis->V_VAR[R711] where ( selected.Name != "self" );
  if ( not_empty v_var )
    nonself_queue_needed = true;
  end if;
end if;
if ( self_queue_needed )
  T::print(s:"Self event queue needed.");
end if;
if ( nonself_queue_needed )
  T::print(s:"Instance event queue needed.");
end if;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO PE_PE
	VALUES ("9ef57745-48d7-4c08-b631-a2a04a629e0f",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("c5801c4c-cb8d-40b2-8437-46847f306ee3",
	"00000000-0000-0000-0000-000000000000",
	'attr_analyze_accesses',
	'',
	'//
//
// Analyze and mark the attributes of the customer model to flag which
// attributes are read and/or written.  We will use this information
// later to optimize out member data access code that is not needed.
// Also, mark attributes participating as identifiers as used.
// Mark written, read and Used attributes to TE_ATTR.
//
attributes_read_count = 0;
attributes_written_count = 0;
//
// Select all the attribute values references.
// Cycle through them marking their associated attributes as being read.
// Then, see if they are written by determining whether they participate
// as an lval in an assignment.
// Note, there can be several V_AVLs for each O_ATTR.
//
select many te_attrs from instances of TE_ATTR;
for each te_attr in te_attrs
  select many v_avls related by te_attr->O_ATTR[R2033]->V_AVL[R806];
  if ( not_empty v_avls )
    if ( not te_attr.read )
      attributes_read_count = attributes_read_count + 1;
    end if;
    te_attr.read = true;
    te_attr.Used = true;
  end if;
  // attributes written
  select any act_ai related by v_avls->V_VAL[R801]->ACT_AI[R689];
  if ( not_empty act_ai )
    if ( not te_attr.written )
      attributes_written_count = attributes_written_count + 1;
      select one te_class related by te_attr->TE_CLASS[R2061];
      if ( te_class.IsReadOnly )
        T::print(s:"ERROR:  Attempt to write to read-only object ${te_class.Name} (${te_class.Key_Lett}).");
      end if;
    end if;
    te_attr.written = true;
  end if;
end for;
// Identifying attributes are copied across in RELATE statements
// even if they are never read or written.
select many o_oidas from instances of O_OIDA;
select many te_attrs related by o_oidas->O_ATTR[R105]->TE_ATTR[R2033];
for each te_attr in te_attrs
  te_attr.Used = true;
end for;
msg = T::s(i:attributes_read_count) + " attributes read";
T::print(s:"${msg}");
msg = T::s(i:attributes_written_count) + " attributes written";
T::print(s:"${msg}");
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO PE_PE
	VALUES ("c5801c4c-cb8d-40b2-8437-46847f306ee3",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("02fea8ef-ab69-41fb-808a-37c3769b725b",
	"00000000-0000-0000-0000-000000000000",
	'attr_analyze_codegen',
	'',
	'//
//
// Mark attributes that are not used, needed and should be optimized out.
//
te_sys = param.te_sys;
optimized_out_count = 0;
select many te_cs from instances of TE_C where ( not selected.OptDisabled );
select many te_attrs related by te_cs->TE_CLASS[R2064]->TE_ATTR[R2061];
for each te_attr in te_attrs
  select one o_attr related by te_attr->O_ATTR[R2033];
  // Do not translate current_state attributes.
  select one s_cdt related by o_attr->S_DT[R114]->S_CDT[R17] where ( selected.Core_Typ == 6 );
  if ( not_empty s_cdt )
    te_attr.translate = false;
    optimized_out_count = optimized_out_count + 1;
  end if;
  if ( not te_attr.Used )
    // not accessed?
    te_attr.translate = false;
    optimized_out_count = optimized_out_count + 1;
  else
    // referential attribute?
    select one o_rattr related by o_attr->O_RATTR[R106];
    if ( not_empty o_rattr )
      // Is referential not also an identifying attribute?
      select any o_oida related by o_attr->O_OIDA[R105] where ( selected.Attr_ID == o_rattr.Attr_ID );
      if ( ( empty o_oida ) and ( not te_attr.Used ) )
        if ( not te_sys.InstanceLoading )
          te_attr.translate = false;
          optimized_out_count = optimized_out_count + 1;
        end if;
      end if;
    end if;
  end if;
end for;
msg = T::s(i:optimized_out_count) + " attributes optimized out";
T::print(s:"${msg}");
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("29ff3581-93d2-496b-997a-1cb23d8ed2cb",
	"02fea8ef-ab69-41fb-808a-37c3769b725b",
	'te_sys',
	"9c3c2949-6ecb-4cf4-9013-792d37160584",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("02fea8ef-ab69-41fb-808a-37c3769b725b",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("095696ec-866a-4a49-a8d2-6113f258095e",
	"00000000-0000-0000-0000-000000000000",
	'association_R_OIR_mark_navigated',
	'',
	'//
//
// Here we mark which classes are navigated across associations in each
// direction, from the formalizer or from the participant.  The results
// are stored in instances linked to instances of R_OIR (TE_OIR).
//
select many act_lnks from instances of ACT_LNK;
for each act_lnk in act_lnks
  select any r_oir related by act_lnk->R_REL[R681]->R_OIR[R201] where ( selected.Obj_ID == act_lnk.Obj_ID );
  select one te_oir related by r_oir->TE_OIR[R2035];
  if ( not_empty te_oir )
    te_oir.NavigatedTo = true;
  end if;
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO PE_PE
	VALUES ("095696ec-866a-4a49-a8d2-6113f258095e",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("41b44c57-cbcc-4f8d-ba11-ac50de9ed6e9",
	"00000000-0000-0000-0000-000000000000",
	'association_mark_link_unlink_needed',
	'',
	'//
//
// Select all of the association instances and mark the ones that
// actually get linked with the relate/unrelate OAL statements.
//
// Mark all navigation (across a particular association).
// Mark all assocations that get navigated.
//
select many te_rels from instances of TE_REL;
select many r_rels related by te_rels->R_REL[R2034];
for each r_rel in r_rels
  link_needed = false;
  unlink_needed = false;
  navigated = false;
  // Check if navigated.
  select any act_lnk related by r_rel->ACT_LNK[R681];
  if ( not_empty act_lnk )
    navigated = true;
  end if;
  // Check if related.
  select any act_rel related by r_rel->ACT_REL[R653];
  if ( not_empty act_rel )
    link_needed = true;
  else
    select any act_ru related by r_rel->ACT_RU[R654];
    if ( not_empty act_ru )
      link_needed = true;
    end if;
  end if;
  // Check if unrelated.
  select any act_unr related by r_rel->ACT_UNR[R655];
  if ( not_empty act_unr )
    unlink_needed = true;
  else
    select any act_uru related by r_rel->ACT_URU[R656];
    if ( not_empty act_uru )
      unlink_needed = true;
    end if;
  end if;
  // Apply results to TE_REL.
  if ( ( link_needed or unlink_needed ) or navigated )
    select one te_rel related by r_rel->TE_REL[R2034];
    if ( navigated )
      te_rel.Navigated = true;
    end if;
    if ( link_needed )
      te_rel.LinkNeeded = true;
    end if;
    if ( unlink_needed )
      te_rel.UnlinkNeeded = true;
    end if;
  end if;
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO PE_PE
	VALUES ("41b44c57-cbcc-4f8d-ba11-ac50de9ed6e9",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("4637f071-2261-4c70-a4bb-8981bb98267a",
	"00000000-0000-0000-0000-000000000000",
	'containoid_select_many_count',
	'',
	'//============================================================================
// Utility functions specifically for OAL analysis.
//============================================================================
//
//
//
// Find the maximum number of "select many" statements expressed in
// one action body.  We will use this number to estimate the container
// pool.
// CDS - This gets called for each component but uses all actions in 
// the system.  And it gets called too many times.
//
result = 0;
select many act_acts from instances of ACT_ACT;
for each act_act in act_acts
  select many act_smts related by act_act->ACT_BLK[R601]->ACT_SMT[R602];
  select many act_sels related by act_smts->ACT_SEL[R603] where ( ( selected.cardinality == "many" ) and ( selected.is_implicit ) );
  select many act_fios related by act_smts->ACT_FIO[R603] where ( ( selected.cardinality == "many" ) and ( selected.is_implicit ) );
  select many act_fiws related by act_smts->ACT_FIW[R603] where ( ( selected.cardinality == "many" ) and ( selected.is_implicit ) );
  count = cardinality act_sels;
  c1 = cardinality act_fios;
  count = count + c1;
  c1 = cardinality act_fiws;
  count = count + c1;
  if ( count > result )
    result = count;
  end if;
end for;
return result;
',
	"ba5eda7a-def5-0000-0000-000000000002",
	1,
	'');
INSERT INTO PE_PE
	VALUES ("4637f071-2261-4c70-a4bb-8981bb98267a",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("55c0ad89-13b7-4d0a-b0df-861f205473f3",
	"00000000-0000-0000-0000-000000000000",
	'timer_analyze_starts',
	'',
	'//
//
// Count up the number of places where a timer is started (or started
// in recurring mode).
//
result = 0;
select any te_target from instances of TE_TARGET;
select many s_ees from instances of S_EE where ( selected.Key_Lett == "TIM" );
if ( "C++" == te_target.language )
  if ( not_empty s_ees )
    result = 1;
  end if;
end if;
for each s_ee in s_ees
  select any s_brg related by s_ee->S_BRG[R19] where ( selected.Name == "timer_start" );
  if ( not_empty s_brg )
    select many timer_invocations related by s_brg->V_BRV[R828];
    c = cardinality timer_invocations;
    result = result + c;
  end if;
  select any s_brg related by s_ee->S_BRG[R19] where ( selected.Name == "timer_start_recurring" );
  if ( not_empty s_brg )
    select many timer_invocations related by s_brg->V_BRV[R828];
    c = cardinality timer_invocations;
    result = result + c;
  end if;
end for;
return result;
',
	"ba5eda7a-def5-0000-0000-000000000002",
	1,
	'');
INSERT INTO PE_PE
	VALUES ("55c0ad89-13b7-4d0a-b0df-861f205473f3",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("695b1bd5-260c-4f66-8e4b-fa47943dad65",
	"00000000-0000-0000-0000-000000000000",
	'CreateSpecialWhereClauseInstances',
	'',
	'//
//============================================================================
// Class: 2000.  Special Where Clause
// CREATE TABLE TE_SWC (
// 	Obj_Kl		STRING,
// 	Where_Spec	STRING,
// 	Key	        STRING,
// 	Ret_Val	        BOOLEAN,
//	Built_In	BOOLEAN,
//	Oid_ID	        INTEGER );
//
// Notes:
// (1) The selected attributes of the where clause _Key_ are specified in the
//     same order as they appear on the OIM. This convention allows other
//     archetypes a _rule_ for dealing with the positional parameter
//     information provided during fragment parsing of a special where clause.
//============================================================================
te_sys = param.te_sys;
//
// Special Where Clause patterns that may be optimized by the model compiler.
//
unique_num = 0;
select many te_classes from instances of TE_CLASS where ( not selected.ExcludeFromGen );
for each te_class in te_classes
  select many o_ids related by te_class->O_OBJ[R2019]->O_ID[R104];
  for each o_id in o_ids
    select one te_where related by o_id->TE_WHERE[R2032];
    // Get all special wheres when loading instances even if they are
    // not seen in the OAL.  We need them for batch_relate.
    if ( te_sys.InstanceLoading )
      select any r_rto related by o_id->R_RTO[R109];
      if ( not_empty r_rto )
        te_where.WhereKey = true;
      end if;
    end if;
    if ( te_where.WhereKey )
      key_number = o_id.Oid_ID + 1;
      where_spec = "";
      unique_num = unique_num + 1;
      where_key = ( ( te_class.Key_Lett + T::s(i:key_number) ) + ( "_mcw" + T::s(i:unique_num) ) );
      //
      select many te_attrs related by te_class->TE_ATTR[R2061];
      for each te_attr in te_attrs
        te_attr.Included = false;
      end for;
      //
      select many te_attrs related by o_id->O_OIDA[R105]->O_ATTR[R105]->TE_ATTR[R2033];
      num_ident_attr = cardinality te_attrs;
      for each te_attr in te_attrs
        te_attr.Included = true;
      end for;
      //
      // *** Provide a key without parenthesis.
      // Be sure we have the first attribute in the class.
      select any first_te_attr related by te_class->TE_ATTR[R2061];
      while ( not_empty first_te_attr )
        select one prev_te_attr related by first_te_attr->TE_ATTR[R2087.''succeeds''];
        if ( empty prev_te_attr )
          break;
        end if;
        first_te_attr = prev_te_attr;
      end while;
      te_attr = first_te_attr;
      oida_count = 0;
      while ( not_empty te_attr )
        select one o_attr related by te_attr->O_ATTR[R2033];
        if ( te_attr.Included )
          oida_count = oida_count + 1;
          where_spec = where_spec + "selected.${o_attr.Name} == ?";
          if ( oida_count < num_ident_attr )
            where_spec = where_spec + " AND ";
          end if;
        end if;
        //
        select one te_attr related by te_attr->TE_ATTR[R2087.''precedes''];
      end while;
      //
      // Object ${te_class.Name} (${te_class.Key_Lett}) Identifier *${key_number}
      create object instance te_swc of TE_SWC;
      relate te_swc to te_class across R2001;
      te_swc.Obj_Kl = te_class.Key_Lett;
      te_swc.Where_Spec = where_spec;
      te_swc.Key = where_key;
      te_swc.Ret_Val = false;
      te_swc.Built_In = true;
      te_swc.Oid_ID = o_id.Oid_ID;
      //
      // *** Provide a key parenthesized at the outer construct.
      where_spec = "(";
      unique_num = unique_num + 1;
      where_key = ( ( te_class.Key_Lett + T::s(i:key_number) ) + ( "_mcw" + T::s(i:unique_num) ) );
      te_attr = first_te_attr;
      oida_count = 0;
      while ( not_empty te_attr )
        select one o_attr related by te_attr->O_ATTR[R2033];
        if ( te_attr.Included )
          oida_count = oida_count + 1;
          where_spec = where_spec + "selected.${o_attr.Name} == ?";
          if ( oida_count < num_ident_attr )
            where_spec = where_spec + " AND ";
          else
            where_spec = where_spec + ")";
          end if;
        end if;
        //
        select one te_attr related by te_attr->TE_ATTR[R2087.''precedes''];
      end while;
      //
      // Object ${te_class.Name} (${te_class.Key_Lett}) Identifier *${key_number}
      create object instance te_swc of TE_SWC;
      relate te_swc to te_class across R2001;
      te_swc.Obj_Kl = te_class.Key_Lett;
      te_swc.Where_Spec = where_spec;
      te_swc.Key = where_key;
      te_swc.Ret_Val = false;
      te_swc.Built_In = true;
      te_swc.Oid_ID = o_id.Oid_ID;
      //
      if ( num_ident_attr > 1 )
        // *** Provide a key parenthesized at outer and inner constructs.
        where_spec = "(";
        unique_num = unique_num + 1;
        where_key = ( ( te_class.Key_Lett + T::s(i:key_number) ) + ( "_mcw" + T::s(i:unique_num) ) );
        te_attr = first_te_attr;
        oida_count = 0;
        while ( not_empty te_attr )
          select one o_attr related by te_attr->O_ATTR[R2033];
          if ( te_attr.Included )
            oida_count = oida_count + 1;
            where_spec = where_spec + "(selected.${o_attr.Name} == ?)";
            if ( oida_count < num_ident_attr )
              where_spec = where_spec + " AND ";
            else
              where_spec = where_spec + ")";
            end if;
          end if;
          //
          select one te_attr related by te_attr->TE_ATTR[R2087.''precedes''];
        end while;
        //
        // Object ${te_class.Name} (${te_class.Key_Lett}) Identifier *${key_number}
        create object instance te_swc of TE_SWC;
        relate te_swc to te_class across R2001;
        te_swc.Obj_Kl = te_class.Key_Lett;
        te_swc.Where_Spec = where_spec;
        te_swc.Key = where_key;
        te_swc.Ret_Val = false;
        te_swc.Built_In = true;
        te_swc.Oid_ID = o_id.Oid_ID;
        // *** Provide a key parenthesized at just inner constructs.
        where_spec = "";
        unique_num = unique_num + 1;
        where_key = ( ( te_class.Key_Lett + T::s(i:key_number) ) + ( "_mcw" + T::s(i:unique_num) ) );
        te_attr = first_te_attr;
        oida_count = 0;
        while ( not_empty te_attr )
          select one o_attr related by te_attr->O_ATTR[R2033];
          if ( te_attr.Included )
            oida_count = oida_count + 1;
            where_spec = where_spec + "(selected.${o_attr.Name} == ?)";
            if ( oida_count < num_ident_attr )
              where_spec = where_spec + " AND ";
            end if;
          end if;
          //
          select one te_attr related by te_attr->TE_ATTR[R2087.''precedes''];
        end while;
        //
        // Object ${te_class.Name} (${te_class.Key_Lett}) Identifier *${key_number}
        create object instance te_swc of TE_SWC;
        relate te_swc to te_class across R2001;
        te_swc.Obj_Kl = te_class.Key_Lett;
        te_swc.Where_Spec = where_spec;
        te_swc.Key = where_key;
        te_swc.Ret_Val = false;
        te_swc.Built_In = true;
        te_swc.Oid_ID = o_id.Oid_ID;
        //
      end if;
    end if;
  end for;
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("a781e518-a05d-4749-a285-bde7f02dcc1d",
	"695b1bd5-260c-4f66-8e4b-fa47943dad65",
	'te_sys',
	"9c3c2949-6ecb-4cf4-9013-792d37160584",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("695b1bd5-260c-4f66-8e4b-fa47943dad65",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("46de9b8a-c5a1-42ef-ae5a-aee29ca422f7",
	"00000000-0000-0000-0000-000000000000",
	'te_parm_RenderParameters',
	'',
	'//============================================================================
// Here we deal with parameters.  The declaration, definition and invocation
// renderings are built.
//============================================================================
//
//
te_parms = param.te_parms;
te_aba = param.te_aba;
// Consider that we may have additional parameters (like for passing "self").
defn = "";
decl = "";
if ( empty te_parms )
  decl = " void";
end if;
invo = "";
stru = "";
parameter_trace = "";
string_format = "";
assn = "";
assnbase = "";
param_delimiter = " ";
format_delimiter = "";
Order = 0;
// Be sure we have the first parameter.
select any te_parm from instances of TE_PARM where ( false );
for each te_parm in te_parms
  break;
end for;
while ( not_empty te_parm )
  select one prev_te_parm related by te_parm->TE_PARM[R2041.''succeeds''];
  if ( empty prev_te_parm )
    break;
  else
    te_parm = prev_te_parm;
  end if;
end while;
while ( not_empty te_parm )
  te_parm.Order = Order;
  Order = Order + 1;
  select one te_dt related by te_parm->TE_DT[R2049];
  te_dt.Included = true;
  defn = defn + param_delimiter;
  decl = decl + param_delimiter;
  param_qual = "";
  if ( 0 != te_parm.By_Ref )
    param_qual = param_qual + " *";
  else
    // CDS const correctness goes here
    // Arrays in C are always by ref, so add const to scalars only.
    if ( ( "" == te_parm.array_spec ) and ( ( 1 <= te_dt.Core_Typ ) and ( te_dt.Core_Typ <= 3 ) ) )
      defn = defn + "const ";
      decl = decl + "const ";
    end if;
  end if;
  defn = ( ( defn + te_dt.ExtName ) + ( param_qual + " " ) ) + ( te_parm.GeneratedName + te_parm.array_spec );
  decl = ( ( decl + te_dt.ExtName ) + ( param_qual + te_parm.array_spec ) );
  invo = ( invo + param_delimiter ) + te_parm.GeneratedName;
  stru = ( ( stru + te_dt.ExtName ) + ( param_qual + " " ) ) + ( ( te_parm.GeneratedName + te_parm.array_spec ) + ";\n" );
  if ( ( "" != te_dt.string_format ) and ( "" == te_parm.array_spec ) )
    // Do not trace structures or arrays.
    dereference = "";
    if ( 0 != te_parm.By_Ref )
      dereference = "*";
    end if;
    parameter_trace = ( parameter_trace + ", " ) + ( dereference + te_parm.GeneratedName );
    string_format = ( string_format + format_delimiter ) + te_dt.string_format;
  else
    string_format = ( string_format + format_delimiter ) + "[]";
  end if;
  r = ::t_oal_smt_event_parameters( evt_msg_var:"", parameter:te_parm.Name, value:te_parm.GeneratedName, value_type:te_dt.Core_Typ, ws:"  " );
  assn = assn + r;
  if ( ( "A00portindex" != te_parm.Name ) and ( "A0xtumlsret" != te_parm.Name ) )
    assnbase = assnbase + r;
  end if;
  param_delimiter = ", ";
  format_delimiter = ",";
  select one te_parm related by te_parm->TE_PARM[R2041.''precedes''];
end while;
if ( "" != defn )
  defn = defn + " ";
end if;
te_aba.ParameterDefinition = defn;
te_aba.ParameterDeclaration = decl + " ";
te_aba.ParameterInvocation = invo;
te_aba.ParameterStructure = stru;
te_aba.ParameterTrace = parameter_trace;
te_aba.ParameterFormat = string_format;
te_aba.ParameterAssignment = assn;
te_aba.ParameterAssignmentBase = assnbase;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("5a3570f7-2d1a-4dfd-a0b2-ed192227578f",
	"46de9b8a-c5a1-42ef-ae5a-aee29ca422f7",
	'te_parms',
	"70195573-bee1-46b0-a3f6-afce8594f5f5",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("70195573-bee1-46b0-a3f6-afce8594f5f5",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref_set<Extended Parameter>',
	'',
	'',
	'../../ooaofooa/Translation Extensions/Translation Extensions.xtuml');
INSERT INTO S_SPARM
	VALUES ("ebade302-fde5-4caf-b09d-620359ceaf80",
	"46de9b8a-c5a1-42ef-ae5a-aee29ca422f7",
	'te_aba',
	"044779c7-f309-4b44-a24c-2b497f1c2c80",
	0,
	'',
	"5a3570f7-2d1a-4dfd-a0b2-ed192227578f",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("044779c7-f309-4b44-a24c-2b497f1c2c80",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Action Block Anchor>',
	'',
	'',
	'../../ooaofooa/Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("46de9b8a-c5a1-42ef-ae5a-aee29ca422f7",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("b53602ca-4719-413c-af82-4d3e2231a985",
	"00000000-0000-0000-0000-000000000000",
	'sparm_sort',
	'',
	'// CDS temporarily order parameters alphabetically for backwards compatibility
s_sparms = param.s_sparms;
for each s_sparm in s_sparms
  select one prev_s_sparm related by s_sparm->S_SPARM[R54.''succeeds''];
  if ( not_empty prev_s_sparm )
    unrelate s_sparm from prev_s_sparm across R54.''succeeds'';
  end if;
end for;
// Declare an empty instance reference.
select any head_s_sparm related by s_sparms->S_SPARM[R54.''succeeds''] where ( false );
for each s_sparm in s_sparms
  r = ::sparm_insert( head_s_sparm:head_s_sparm, s_sparm:s_sparm );
  head_s_sparm = r;
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("7bbd6afd-e8c3-4acd-8fba-f42401ab60fc",
	"b53602ca-4719-413c-af82-4d3e2231a985",
	's_sparms',
	"e8b1f806-296f-4032-a73d-3ab541f85aa8",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("e8b1f806-296f-4032-a73d-3ab541f85aa8",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref_set<Function Parameter>',
	'',
	'',
	'../../ooaofooa/Domain/Domain.xtuml');
INSERT INTO PE_PE
	VALUES ("b53602ca-4719-413c-af82-4d3e2231a985",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("6e223a7b-9fc0-4159-8857-5c828c57c177",
	"00000000-0000-0000-0000-000000000000",
	'sparm_insert',
	'',
	'head_s_sparm = param.head_s_sparm;
s_sparm = param.s_sparm;
result = s_sparm;
if ( empty head_s_sparm )
  // Just starting.  Return s_sparm as head.
elif ( s_sparm.Name <= head_s_sparm.Name )
  // insert before
  relate s_sparm to head_s_sparm across R54.''precedes'';
else
  // find bigger
  result = head_s_sparm;
  prev_s_sparm = head_s_sparm;
  select one cursor_s_sparm related by head_s_sparm->S_SPARM[R54.''precedes''];
  while ( not_empty cursor_s_sparm )
    if ( s_sparm.Name <= cursor_s_sparm.Name )
      break;
    else
      prev_s_sparm = cursor_s_sparm;
      select one cursor_s_sparm related by cursor_s_sparm->S_SPARM[R54.''precedes''];
    end if;
  end while;
  relate prev_s_sparm to s_sparm across R54.''precedes'';
  if ( not_empty cursor_s_sparm )
    relate s_sparm to cursor_s_sparm across R54.''precedes'';
  end if;
end if;
return result;
',
	"a01a1995-8ff8-44fe-abb1-b11213d98016",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("0e98d589-6197-4a9a-8b21-808432bfb576",
	"6e223a7b-9fc0-4159-8857-5c828c57c177",
	'head_s_sparm',
	"a01a1995-8ff8-44fe-abb1-b11213d98016",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("a01a1995-8ff8-44fe-abb1-b11213d98016",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Function Parameter>',
	'',
	'',
	'../../ooaofooa/Domain/Domain.xtuml');
INSERT INTO S_SPARM
	VALUES ("eedf3caa-e1da-4a57-ab8f-181b22e62502",
	"6e223a7b-9fc0-4159-8857-5c828c57c177",
	's_sparm',
	"a01a1995-8ff8-44fe-abb1-b11213d98016",
	0,
	'',
	"0e98d589-6197-4a9a-8b21-808432bfb576",
	'');
INSERT INTO PE_PE
	VALUES ("6e223a7b-9fc0-4159-8857-5c828c57c177",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("e3deb438-043a-496d-85f4-8199e1a65e75",
	"00000000-0000-0000-0000-000000000000",
	'bparm_sort',
	'',
	'//
//
s_bparms = param.s_bparms;
for each s_bparm in s_bparms
  select one prev_s_bparm related by s_bparm->S_BPARM[R55.''succeeds''];
  if ( not_empty prev_s_bparm )
    unrelate s_bparm from prev_s_bparm across R55.''succeeds'';
  end if;
end for;
// Declare an empty instance reference.
select any head_s_bparm related by s_bparms->S_BPARM[R55.''succeeds''] where ( false );
for each s_bparm in s_bparms
  r = ::bparm_insert( head_s_bparm:head_s_bparm, s_bparm:s_bparm );
  head_s_bparm = r;
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("7f645c0c-ab09-4616-8a90-577f6685cfbd",
	"e3deb438-043a-496d-85f4-8199e1a65e75",
	's_bparms',
	"1b82028b-2da0-445f-af4b-ceca6fb8ae52",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("1b82028b-2da0-445f-af4b-ceca6fb8ae52",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref_set<Bridge Parameter>',
	'',
	'',
	'../../ooaofooa/Domain/Domain.xtuml');
INSERT INTO PE_PE
	VALUES ("e3deb438-043a-496d-85f4-8199e1a65e75",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("354225e9-b424-40a2-b650-7c8de449c1be",
	"00000000-0000-0000-0000-000000000000",
	'bparm_insert',
	'',
	'head_s_bparm = param.head_s_bparm;
s_bparm = param.s_bparm;
result = s_bparm;
if ( empty head_s_bparm )
  // Just starting.  Return s_bparm as head.
elif ( s_bparm.Name <= head_s_bparm.Name )
  // insert before
  relate s_bparm to head_s_bparm across R55.''precedes'';
else
  // find bigger
  result = head_s_bparm;
  prev_s_bparm = head_s_bparm;
  select one cursor_s_bparm related by head_s_bparm->S_BPARM[R55.''precedes''];
  while ( not_empty cursor_s_bparm )
    if ( s_bparm.Name <= cursor_s_bparm.Name )
      break;
    else
      prev_s_bparm = cursor_s_bparm;
      select one cursor_s_bparm related by cursor_s_bparm->S_BPARM[R55.''precedes''];
    end if;
  end while;
  relate prev_s_bparm to s_bparm across R55.''precedes'';
  if ( not_empty cursor_s_bparm )
    relate s_bparm to cursor_s_bparm across R55.''precedes'';
  end if;
end if;
return result;
',
	"024c3ad1-7845-4590-9c38-01e43cf1de89",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("5fb88cad-427f-4ce3-a45f-c05b622ec046",
	"354225e9-b424-40a2-b650-7c8de449c1be",
	'head_s_bparm',
	"024c3ad1-7845-4590-9c38-01e43cf1de89",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("024c3ad1-7845-4590-9c38-01e43cf1de89",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Bridge Parameter>',
	'',
	'',
	'../../ooaofooa/Domain/Domain.xtuml');
INSERT INTO S_SPARM
	VALUES ("e5a18486-d923-4e19-ac57-5b9dd6faeece",
	"354225e9-b424-40a2-b650-7c8de449c1be",
	's_bparm',
	"024c3ad1-7845-4590-9c38-01e43cf1de89",
	0,
	'',
	"5fb88cad-427f-4ce3-a45f-c05b622ec046",
	'');
INSERT INTO PE_PE
	VALUES ("354225e9-b424-40a2-b650-7c8de449c1be",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("61ce64b0-f359-47a1-a2b5-8a13c74a754d",
	"00000000-0000-0000-0000-000000000000",
	'tparm_sort',
	'',
	'//
//
o_tparms = param.o_tparms;
for each o_tparm in o_tparms
  select one prev_o_tparm related by o_tparm->O_TPARM[R124.''succeeds''];
  if ( not_empty prev_o_tparm )
    unrelate o_tparm from prev_o_tparm across R124.''succeeds'';
  end if;
end for;
// Declare an empty instance reference.
select any head_o_tparm related by o_tparms->O_TPARM[R124.''succeeds''] where ( false );
for each o_tparm in o_tparms
  r = ::tparm_insert( head_o_tparm:head_o_tparm, o_tparm:o_tparm );
  head_o_tparm = r;
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("83893b61-7278-437f-af6a-cfce11273bed",
	"61ce64b0-f359-47a1-a2b5-8a13c74a754d",
	'o_tparms',
	"4f2e65bb-06e0-4b2f-9b91-5d04cab4db0f",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("4f2e65bb-06e0-4b2f-9b91-5d04cab4db0f",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref_set<Operation Parameter>',
	'',
	'',
	'../../ooaofooa/Subsystem/Subsystem.xtuml');
INSERT INTO PE_PE
	VALUES ("61ce64b0-f359-47a1-a2b5-8a13c74a754d",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("e9a9a56c-f50a-4058-a5f4-b9285595ea47",
	"00000000-0000-0000-0000-000000000000",
	'tparm_insert',
	'',
	'head_o_tparm = param.head_o_tparm;
o_tparm = param.o_tparm;
result = o_tparm;
if ( empty head_o_tparm )
  // Just starting.  Return o_tparm as head.
elif ( o_tparm.Name <= head_o_tparm.Name )
  // insert before
  relate o_tparm to head_o_tparm across R124.''precedes'';
else
  // find bigger
  result = head_o_tparm;
  prev_o_tparm = head_o_tparm;
  select one cursor_o_tparm related by head_o_tparm->O_TPARM[R124.''precedes''];
  while ( not_empty cursor_o_tparm )
    if ( o_tparm.Name <= cursor_o_tparm.Name )
      break;
    else
      prev_o_tparm = cursor_o_tparm;
      select one cursor_o_tparm related by cursor_o_tparm->O_TPARM[R124.''precedes''];
    end if;
  end while;
  relate prev_o_tparm to o_tparm across R124.''precedes'';
  if ( not_empty cursor_o_tparm )
    relate o_tparm to cursor_o_tparm across R124.''precedes'';
  end if;
end if;
return result;
',
	"eeb98cba-1a0c-4d36-80f1-c0199a301aaf",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("21991e6c-30d4-4741-9a78-fd5afe066b78",
	"e9a9a56c-f50a-4058-a5f4-b9285595ea47",
	'head_o_tparm',
	"eeb98cba-1a0c-4d36-80f1-c0199a301aaf",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("eeb98cba-1a0c-4d36-80f1-c0199a301aaf",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Operation Parameter>',
	'',
	'',
	'../../ooaofooa/Subsystem/Subsystem.xtuml');
INSERT INTO S_SPARM
	VALUES ("6a6f9b0e-2306-4a77-bea0-7d0d06dd0d55",
	"e9a9a56c-f50a-4058-a5f4-b9285595ea47",
	'o_tparm',
	"eeb98cba-1a0c-4d36-80f1-c0199a301aaf",
	0,
	'',
	"21991e6c-30d4-4741-9a78-fd5afe066b78",
	'');
INSERT INTO PE_PE
	VALUES ("e9a9a56c-f50a-4058-a5f4-b9285595ea47",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("43fa1e1c-ba69-4750-a8c3-955b01881145",
	"00000000-0000-0000-0000-000000000000",
	'evtdi_sort',
	'',
	'//
//
sm_evtdis = param.sm_evtdis;
for each sm_evtdi in sm_evtdis
  select one prev_sm_evtdi related by sm_evtdi->SM_EVTDI[R533.''succeeds''];
  if ( not_empty prev_sm_evtdi )
    unrelate sm_evtdi from prev_sm_evtdi across R533.''succeeds'';
  end if;
end for;
// Declare an empty instance reference.
select any head_sm_evtdi related by sm_evtdis->SM_EVTDI[R533.''succeeds''] where ( false );
for each sm_evtdi in sm_evtdis
  r = ::evtdi_insert( head_sm_evtdi:head_sm_evtdi, sm_evtdi:sm_evtdi );
  head_sm_evtdi = r;
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("bc75f3a9-f477-4e2b-80d3-2c563dcbcb79",
	"43fa1e1c-ba69-4750-a8c3-955b01881145",
	'sm_evtdis',
	"57bb0ec0-a32f-4e67-8eb9-b287b2325a45",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("57bb0ec0-a32f-4e67-8eb9-b287b2325a45",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref_set<State Machine Event Data Item>',
	'',
	'',
	'../../ooaofooa/State Machine/State Machine.xtuml');
INSERT INTO PE_PE
	VALUES ("43fa1e1c-ba69-4750-a8c3-955b01881145",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("00ecec66-d389-4d56-8db6-a6a5745eb992",
	"00000000-0000-0000-0000-000000000000",
	'evtdi_insert',
	'',
	'head_sm_evtdi = param.head_sm_evtdi;
sm_evtdi = param.sm_evtdi;
result = sm_evtdi;
if ( empty head_sm_evtdi )
  // Just starting.  Return sm_evtdi as head.
elif ( sm_evtdi.Name <= head_sm_evtdi.Name )
  // insert before
  relate sm_evtdi to head_sm_evtdi across R533.''precedes'';
else
  // find bigger
  result = head_sm_evtdi;
  prev_sm_evtdi = head_sm_evtdi;
  select one cursor_sm_evtdi related by head_sm_evtdi->SM_EVTDI[R533.''precedes''];
  while ( not_empty cursor_sm_evtdi )
    if ( sm_evtdi.Name <= cursor_sm_evtdi.Name )
      break;
    else
      prev_sm_evtdi = cursor_sm_evtdi;
      select one cursor_sm_evtdi related by cursor_sm_evtdi->SM_EVTDI[R533.''precedes''];
    end if;
  end while;
  relate prev_sm_evtdi to sm_evtdi across R533.''precedes'';
  if ( not_empty cursor_sm_evtdi )
    relate sm_evtdi to cursor_sm_evtdi across R533.''precedes'';
  end if;
end if;
return result;
',
	"9067a5b1-aa5d-499a-b13e-9bde5fc3e2cd",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("954dcc63-38d5-43b2-bd29-8b7f327dd297",
	"00ecec66-d389-4d56-8db6-a6a5745eb992",
	'head_sm_evtdi',
	"9067a5b1-aa5d-499a-b13e-9bde5fc3e2cd",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("9067a5b1-aa5d-499a-b13e-9bde5fc3e2cd",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<State Machine Event Data Item>',
	'',
	'',
	'../../ooaofooa/State Machine/State Machine.xtuml');
INSERT INTO S_SPARM
	VALUES ("933596ae-3c7b-4c77-b0f8-18198ce734bc",
	"00ecec66-d389-4d56-8db6-a6a5745eb992",
	'sm_evtdi',
	"9067a5b1-aa5d-499a-b13e-9bde5fc3e2cd",
	0,
	'',
	"954dcc63-38d5-43b2-bd29-8b7f327dd297",
	'');
INSERT INTO PE_PE
	VALUES ("00ecec66-d389-4d56-8db6-a6a5745eb992",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("498e64b1-e5c8-4d2b-9930-a12ea059503c",
	"00000000-0000-0000-0000-000000000000",
	'pp_sort',
	'',
	'//
//
c_pps = param.c_pps;
for each c_pp in c_pps
  select one prev_c_pp related by c_pp->C_PP[R4021.''succeeds''];
  if ( not_empty prev_c_pp )
    unrelate c_pp from prev_c_pp across R4021.''succeeds'';
  end if;
end for;
// Declare an empty instance reference.
select any head_c_pp related by c_pps->C_PP[R4021.''succeeds''] where ( false );
for each c_pp in c_pps
  r = ::pp_insert( head_c_pp:head_c_pp, c_pp:c_pp );
  head_c_pp = r;
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("53866196-9a74-4078-9ea4-704f8795c6d5",
	"498e64b1-e5c8-4d2b-9930-a12ea059503c",
	'c_pps',
	"4bb6b175-de43-4bbf-9d4f-0bdd34ab8988",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("4bb6b175-de43-4bbf-9d4f-0bdd34ab8988",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref_set<Property Parameter>',
	'',
	'',
	'../../ooaofooa/Component/Component.xtuml');
INSERT INTO PE_PE
	VALUES ("498e64b1-e5c8-4d2b-9930-a12ea059503c",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("b6058d96-83d1-466c-92fa-0ebce006d485",
	"00000000-0000-0000-0000-000000000000",
	'pp_insert',
	'',
	'head_c_pp = param.head_c_pp;
c_pp = param.c_pp;
result = c_pp;
if ( empty head_c_pp )
  // Just starting.  Return c_pp as head.
elif ( c_pp.Name <= head_c_pp.Name )
  // insert before
  relate c_pp to head_c_pp across R4021.''precedes'';
else
  // find bigger
  result = head_c_pp;
  prev_c_pp = head_c_pp;
  select one cursor_c_pp related by head_c_pp->C_PP[R4021.''precedes''];
  while ( not_empty cursor_c_pp )
    if ( c_pp.Name <= cursor_c_pp.Name )
      break;
    else
      prev_c_pp = cursor_c_pp;
      select one cursor_c_pp related by cursor_c_pp->C_PP[R4021.''precedes''];
    end if;
  end while;
  relate prev_c_pp to c_pp across R4021.''precedes'';
  if ( not_empty cursor_c_pp )
    relate c_pp to cursor_c_pp across R4021.''precedes'';
  end if;
end if;
return result;
',
	"4d4c0ef2-2520-4dbe-8096-a56393ea3f85",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("259f7a4b-8103-4b87-87c4-e13c7bce06b7",
	"b6058d96-83d1-466c-92fa-0ebce006d485",
	'head_c_pp',
	"4d4c0ef2-2520-4dbe-8096-a56393ea3f85",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("4d4c0ef2-2520-4dbe-8096-a56393ea3f85",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Property Parameter>',
	'',
	'',
	'../../ooaofooa/Component/Component.xtuml');
INSERT INTO S_SPARM
	VALUES ("a60c4eaf-b45c-40a3-a038-2609ca6f148f",
	"b6058d96-83d1-466c-92fa-0ebce006d485",
	'c_pp',
	"4d4c0ef2-2520-4dbe-8096-a56393ea3f85",
	0,
	'',
	"259f7a4b-8103-4b87-87c4-e13c7bce06b7",
	'');
INSERT INTO PE_PE
	VALUES ("b6058d96-83d1-466c-92fa-0ebce006d485",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("8d940247-7cc7-4a8f-a79e-68c938837feb",
	"00000000-0000-0000-0000-000000000000",
	'parm_sort',
	'',
	'//
// CDS temporary for sorting model data parameters
if ( true )
  select many s_syncs from instances of S_SYNC;
  for each s_sync in s_syncs
    select many s_sparms related by s_sync->S_SPARM[R24];
    ::sparm_sort( s_sparms:s_sparms );
  end for;
  select many s_brgs from instances of S_BRG;
  for each s_brg in s_brgs
    select many s_bparms related by s_brg->S_BPARM[R21];
    ::bparm_sort( s_bparms:s_bparms );
  end for;
  select many o_tfrs from instances of O_TFR;
  for each o_tfr in o_tfrs
    select many o_tparms related by o_tfr->O_TPARM[R117];
    ::tparm_sort( o_tparms:o_tparms );
  end for;
  select many sm_evts from instances of SM_EVT;
  for each sm_evt in sm_evts
    select many sm_evtdis related by sm_evt->SM_EVTDI[R532];
    ::evtdi_sort( sm_evtdis:sm_evtdis );
  end for;
  select many c_eps from instances of C_EP;
  for each c_ep in c_eps
    select many c_pps related by c_ep->C_PP[R4006];
    ::pp_sort( c_pps:c_pps );
  end for;
end if;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO PE_PE
	VALUES ("8d940247-7cc7-4a8f-a79e-68c938837feb",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("43fda7fe-0b51-4f0a-a2d7-8e61b34c89e1",
	"00000000-0000-0000-0000-000000000000",
	'rel_pseudoformalize',
	'',
	'//============================================================================
// This query/transformation archetype file contains the functionality
// that will allow the model compiler to generate code for unformalized 
// associations (associations that have not been formalized).
//============================================================================
//
// Find the associations that are not formalized.  They are characterized
// by the existence of 2 instances of R_PART linked to one R_SIMP.
// Migrate the R_PART/R_RTO pair to R_FORM/R_RGO.
// It does not matter which participant we choose unless this is a many
// association.  Grab the many side of a 1-M or any random R_PART and
// migrate it and its parent R_RTO to R_FORM and R_RGO respectively.
select many r_simps from instances of R_SIMP;
for each r_simp in r_simps
  select many r_parts related by r_simp->R_PART[R207];
  if ( ( cardinality r_parts ) > 1 )
    select any r_part related by r_simp->R_PART[R207] where ( selected.Mult == 1 );
    if ( empty r_part )
      select any r_part related by r_simp->R_PART[R207];
    end if;
    select one r_rto related by r_part->R_RTO[R204];
    select one r_oir related by r_rto->R_OIR[R203];
    //
    create object instance r_rgo of R_RGO;
    create object instance r_form of R_FORM;
    //
    // Copy the R_PART to the new R_FORM.
    r_form.Mult = r_part.Mult;
    r_form.Cond = r_part.Cond;
    r_form.Txt_Phrs = r_part.Txt_Phrs;
    //
    unrelate r_part from r_rto across R204;
    unrelate r_part from r_simp across R207;
    delete object instance r_part;
    //
    unrelate r_rto from r_oir across R203;
    delete object instance r_rto;
    //
    relate r_rgo to r_oir across R203;
    relate r_form to r_rgo across R205;
    relate r_form to r_simp across R208;
  end if;
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO PE_PE
	VALUES ("43fda7fe-0b51-4f0a-a2d7-8e61b34c89e1",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("0b057462-c85f-4f46-b529-07122c615f4a",
	"00000000-0000-0000-0000-000000000000",
	'sys_populate',
	'',
	'//============================================================================
// This query/transformation archetype file queries the customer model
// and populates the model compiler extensions to the meta-model.
// Instances of the extended classes are created, related and initialized.
//
// Create architectural system-level artifacts first.
// Create leaf-node artifacts (like TE_DT, TE_VAL and TE_PAR) which may need
// to be updated as information is gathered.
// Create component-level artifacts.
// Briefly create and link components, data types.  Select them afterwards.
// Create and link middled-level classes.
// Drill down into component and create object, attributes and the rest.
//============================================================================
//
//
// Create the system interfaces (sys, dom, ee).
//
// Select singletons into scope.
select any te_file from instances of TE_FILE;
select any te_eq from instances of TE_EQ;
select any te_extent from instances of TE_EXTENT;
select any te_instance from instances of TE_INSTANCE;
select any te_prefix from instances of TE_PREFIX;
select any te_set from instances of TE_SET;
select any te_string from instances of TE_STRING;
select any te_target from instances of TE_TARGET;
select any te_thread from instances of TE_THREAD;
select any te_tim from instances of TE_TIM;
select any te_typemap from instances of TE_TYPEMAP;
select many empty_ep_pkgs from instances of EP_PKG where ( false );
select any empty_te_c from instances of TE_C where ( false );
select any empty_te_dim from instances of TE_DIM where ( false );
select many empty_s_dims from instances of S_DIM where ( false );
select any empty_o_obj from instances of O_OBJ where ( false );
select any empty_te_attr from instances of TE_ATTR where ( false );
select any empty_te_mact from instances of TE_MACT where ( false );
select many empty_te_dts from instances of TE_DT where ( false );
select many empty_te_parms from instances of TE_PARM where ( false );
// CDS - Note that in a multiple-system build, we will get lucky, and the
// s_sys from the local project will be selected first.
select any s_sys from instances of S_SYS;
if ( empty s_sys )
  create object instance s_sys of S_SYS;
  s_sys.Name = "sys";
end if;
// Create the system translation extension and relate it.
select any te_sys from instances of TE_SYS;
if ( empty te_sys )
  create object instance te_sys of TE_SYS;
  te_sys.SystemID = 1;
end if;
relate s_sys to te_sys across R2018;
te_sys.Name = T::r(s:s_sys.Name);
if ( "" == te_sys.Name )
  te_sys.Name = "sys";
end if;
te_sys.MaxStringLen = 32;
te_sys.PersistInstanceCacheDepth = 128;
te_sys.PersistLinkCacheDepth = 128;
te_sys.AUTOSAR = false;
te_sys.AllPortsPoly = false;
te_sys.StructuredMessaging = false;
te_sys.NetworkSockets = false;
//
// Update te_sys with system marks
select any tm_systag from instances of TM_SYSTAG;
if ( not_empty tm_systag )
  te_sys.MaxStringLen = tm_systag.MaxStringLen;
  te_sys.MaxRelExtent = tm_systag.MaxRelExtent;
  te_sys.MaxSelectExtent = tm_systag.MaxSelectExtent;
  te_sys.MaxSelfEvents = tm_systag.MaxSelfEvents;
  te_sys.MaxNonSelfEvents = tm_systag.MaxNonSelfEvents;
  te_sys.MaxTimers = tm_systag.MaxTimers;
  te_sys.MaxInterleavedBridges = tm_systag.MaxInterleavedBridges;
  te_sys.MaxInterleavedBridgeDataSize = tm_systag.MaxInterleavedBridgeDataSize;
  te_sys.CollectionsFlavor = tm_systag.CollectionsFlavor;
  te_sys.PersistInstanceCacheDepth = tm_systag.PersistInstanceCacheDepth;
  te_sys.PersistLinkCacheDepth = tm_systag.PersistLinkCacheDepth;
  te_sys.UnitsToDynamicallyAllocate = tm_systag.UnitsToDynamicallyAllocate;
  te_sys.VFB = tm_systag.VFB;
  te_sys.InstanceLoading = tm_systag.InstanceLoading;
  te_sys.SystemCPortsType = tm_systag.SystemCPortsType;
  te_sys.AllPortsPoly = tm_systag.AllPortsPoly;
  te_sys.StructuredMessaging = tm_systag.StructuredMessaging;
  te_sys.NetworkSockets = tm_systag.NetworkSockets;
else
  te_sys.SystemCPortsType = "sc_interface";
end if;
//
// Update the tasking threads based on marking.
select any tm_thread from instances of TM_THREAD;
if ( not_empty tm_thread )
  te_thread.extra_initialization = tm_thread.extra_initialization;
  te_thread.number_of_threads = tm_thread.number_of_threads;
  te_thread.enabled = tm_thread.enabled;
  te_thread.serialize = tm_thread.serialize;
  te_thread.flavor = tm_thread.flavor;
  if ( "AUTOSAR" == te_thread.flavor )
    te_sys.AUTOSAR = true;
  end if;
end if;
//
select any te_disp from instances of TE_DISP;
if ( empty te_disp )
  create object instance te_disp of TE_DISP;
  te_disp.Dispatcher_ID = 1;
  relate te_disp to te_sys across R2003;
end if;
te_disp.Descrip = "dispatcher";
te_disp.Name = "main";
select any te_queue from instances of TE_QUEUE;
select any nonself_te_queue from instances of TE_QUEUE;
if ( empty te_queue )
  create object instance te_queue of TE_QUEUE;
  te_queue.Queue_ID = 1;
  relate te_queue to te_disp across R2004;
  create object instance nonself_te_queue of TE_QUEUE;
  nonself_te_queue.Queue_ID = 2;
  relate nonself_te_queue to te_disp across R2004;
end if;
// Self Queue
te_queue.Descrip = "Self Queue";
te_queue.RenderCode = false;
te_queue.MaxDepth = 0;
te_queue.Type = 1;
// NonSelf Queue
nonself_te_queue.Descrip = "NonSelf Queue";
nonself_te_queue.RenderCode = false;
nonself_te_queue.MaxDepth = 0;
nonself_te_queue.Type = 2;
//
// Create the (domain) class info array instance.
// CDS - This may end up being part of a component rather than a system.
create object instance te_cia of TE_CIA;
te_cia.class_info_name = "domain_class_info";
te_cia.class_info_type = te_extent.type;
te_cia.active_count = "active_count";
te_cia.class_count = "domain_class_count";
te_cia.count_type = te_typemap.object_number_name;
//
//
// Create the Extended Component instance(s) and link them up.
select many c_cs from instances of C_C;
for each c_c in c_cs
  create object instance te_c of TE_C;
  relate te_c to c_c across R2054;
  relate te_c to te_sys across R2065;
  te_c.Name = T::r(s:c_c.Name);
  te_c.Descrip = c_c.Descrip;
  te_c.included_in_build = true;
        select any tm_c from instances of TM_C where ( selected.Name == c_c.Name );
  if ( not_empty tm_c )
    if ( ( tm_c.isRealized ) or ( c_c.isRealized ) )
      // Component is realized, so skip translation of internals.
      te_c.isRealized = true;
    end if;
  end if;
  te_c.internal_behavior = false;
  te_c.module_file = te_c.Name;
  te_c.port_file = te_c.Name;
  te_c.classes_file = te_c.Name + "_classes";
  te_c.CodeComments = true;
  // Create and relate the domain class info to carry details about
  // class extents for this component.
  create object instance te_dci of TE_DCI;
  relate te_dci to te_c across R2090;
  te_dci.class_numbers = te_c.Name + "_CLASS_NUMBERS";
  te_dci.persist_union = te_c.Name + "_CLASS_U";
  te_dci.task_list = te_c.Name + "_task_numbers";
  te_dci.task_numbers = te_c.Name + "_TASK_NUMBERS";
  te_dci.max = te_c.Name + "_MAX_CLASS_NUMBERS";
  te_dci.max_models = te_c.Name + "_STATE_MODELS";
  te_dci.init = te_c.Name + "_CLASS_INFO_INIT";
  te_dci.array_name = te_c.Name + "_class_info";
  // Create the Component Instance instances.
  select many cl_ics related by c_c->CL_IC[R4201];
  for each cl_ic in cl_ics
    create object instance te_ci of TE_CI;
    te_ci.Name = te_c.Name;
    if ( "" == cl_ic.ClassifierName )
      te_ci.ClassifierName = "i" + te_c.Name;
    else
      te_ci.ClassifierName = T::r(s:cl_ic.ClassifierName);
    end if;
    relate te_ci to te_c across R2008;
    relate te_ci to cl_ic across R2009;
  end for;
  // Create the Extended Ports.
  select many c_pos related by c_c->C_PO[R4010];
  for each c_po in c_pos
    select any c_i related by c_po->C_IR[R4016]->C_I[R4012];
    if ( not_empty c_i )
      create object instance te_po of TE_PO;
      relate te_po to c_po across R2044;
      relate te_po to te_c across R2005;
      relate te_po to c_i across R2007;
      te_po.InterfaceName = T::r(s:c_i.Name);
      select any c_r related by c_po->C_IR[R4016]->C_R[R4009];
      if ( not_empty c_r )
        te_po.Provision = false;
      else
        te_po.Provision = true;
      end if;
      te_po.polymorphic = false;
      te_po.sibling = 0;
      te_po.Name = c_po.Name;
      te_po.GeneratedName = T::r(s:te_po.Name);
      // Create the Interface Instance instances.
      select many c_irs related by c_po->C_IR[R4016];
      for each c_ir in c_irs
        create object instance te_iir of TE_IIR;
                        relate te_iir to c_ir across R2046;
        relate te_iir to te_po across R2080;
        te_iir.component_name = c_c.Name;
        te_iir.port_name = te_po.Name;
        te_iir.interface_name = te_po.InterfaceName;
        te_iir.polymorphic = false;
        select many cl_iirs related by c_ir->CL_IIR[R4701];
        for each cl_iir in cl_iirs
          create object instance te_iir of TE_IIR;
                              relate te_iir to cl_iir across R2013;
          relate te_iir to te_po across R2080;
          te_iir.port_name = te_po.Name;
          te_iir.interface_name = te_po.InterfaceName;
          te_iir.polymorphic = false;
        end for;
      end for;
    end if;
  end for;
  // Identify polymorhic ports.
  // Polymorphic ports exist more than once in the same orientation on a component.
  port_counter = 0;
  select many te_pos related by te_c->TE_PO[R2005];
  for each te_po in te_pos
    te_po.Order = port_counter;
    port_counter = port_counter + 1;
    select many poly_te_pos related by te_po->TE_C[R2005]->TE_PO[R2005] where ( ( ( selected.c_iId == te_po.c_iId ) and ( selected.Provision == te_po.Provision ) ) and ( selected.ID != te_po.ID ) );
    if ( not_empty poly_te_pos )
      // If we have seen this port already, it will be marked as polymorphic.
      // So, no need to iterate marking as not the first sibling.
      if ( not te_po.polymorphic )
        sibling_counter = 1;
        for each poly_te_po in poly_te_pos
          poly_te_po.polymorphic = true;
          poly_te_po.sibling = sibling_counter;
          sibling_counter = sibling_counter + 1;
        end for;
      end if;
      te_po.polymorphic = true;
      // Now mark the related interface reference instances as polymorphic.
      select many te_iirs related by te_po->TE_IIR[R2080];
      for each te_iir in te_iirs
        te_iir.polymorphic = true;
      end for;
    end if;
  end for;
end for;
// Here we force all the ports and interface references to be polymorphic.  
// We do this step via a second loop here so that we could set up the 
// sibling values earlier before all the ports potentially get forced to polymorphic.
// This loop also configures the satisfaction shortcut we create between local and
// foreign interface references.
select many te_pos from instances of TE_PO;
for each te_po in te_pos
  select many te_iirs related by te_po->TE_IIR[R2080];
  for each te_iir in te_iirs
    // Select across the satisfaction to get the related TE_IIR.
    if ( te_po.Provision )
      // provision side first
      // CDS There may be more than one here.
      select any foreign_te_iir related by te_iir->CL_IIR[R2013]->CL_IP[R4703]->CL_IPINS[R4705]->C_SF[R4705]->CL_IR[R4706]->CL_IIR[R4703]->TE_IIR[R2013];
      if ( empty foreign_te_iir )
        // We are dealing with TE_IIRs that may be on non-imported interface references (connected to C_Cs).
        select any foreign_te_iir related by te_iir->C_IR[R2046]->C_P[R4009]->C_SF[R4002]->C_R[R4002]->C_IR[R4009]->TE_IIR[R2046];
        if ( empty foreign_te_iir )
          select any foreign_te_iir related by te_iir->CL_IIR[R2013]->CL_IP[R4703]->CL_IPINS[R4705]->C_SF[R4705]->C_R[R4002]->C_IR[R4009]->TE_IIR[R2046];
          if ( empty foreign_te_iir )
            select any foreign_te_iir related by te_iir->C_IR[R2046]->C_P[R4009]->C_SF[R4002]->CL_IR[R4706]->CL_IIR[R4703]->TE_IIR[R2013];
          end if;
        end if;
      end if;
      if ( not_empty foreign_te_iir )
        relate te_iir to foreign_te_iir across R2081.''provides or is delegated'';
      end if;
    else
      // requirement side first
      select one foreign_te_iir related by te_iir->CL_IIR[R2013]->CL_IR[R4703]->C_SF[R4706]->CL_IPINS[R4705]->CL_IP[R4705]->CL_IIR[R4703]->TE_IIR[R2013];
      if ( empty foreign_te_iir )
        select any foreign_te_iir related by te_iir->C_IR[R2046]->C_R[R4009]->C_SF[R4002]->C_P[R4002]->C_IR[R4009]->TE_IIR[R2046];
        if ( empty foreign_te_iir )
          select one foreign_te_iir related by te_iir->CL_IIR[R2013]->CL_IR[R4703]->C_SF[R4706]->C_P[R4002]->C_IR[R4009]->TE_IIR[R2046];
          if ( empty foreign_te_iir )
            select any foreign_te_iir related by te_iir->C_IR[R2046]->C_R[R4009]->C_SF[R4002]->CL_IPINS[R4705]->CL_IP[R4705]->CL_IIR[R4703]->TE_IIR[R2013];
          end if;
        end if;
      end if;
      if ( not_empty foreign_te_iir )
        relate te_iir to foreign_te_iir across R2081.''requires or delegates'';
      end if;
    end if;
  end for;
end for;
//
// By default, select all components to be translated.  However, if
// a package has been marked, translate only the components contained
// in the package (or referenced from it).
ep_pkgs = empty_ep_pkgs;
package_to_build = "";
select any tm_build from instances of TM_BUILD;
markedsystems = 0;
if ( not_empty tm_build )
  select many ep_pkgs from instances of EP_PKG where ( selected.Name == tm_build.package_to_build );
  markedsystems = cardinality ep_pkgs;
  if ( empty ep_pkgs )
    T::print(s:"ERROR:  Marked configuration package ${tm_build.package_to_build} was not found in model.  Exiting.");
    T::exit(i:11);
  end if;
  package_to_build = tm_build.package_to_build;
end if;
if ( markedsystems > 1 )
  T::print(s:"WARNING:  More than one package is marked as a system build... choose only one.");
end if;
if ( "" != package_to_build )
  T::print(s:"Marked configuration package ${package_to_build} found.");
  select many te_cs from instances of TE_C;
  // Clear the build flag for all components and then mark only those
  // requested by the marking.
  for each te_c in te_cs
    te_c.included_in_build = false;
  end for;
  select many te_cs related by ep_pkgs->PE_PE[R8000]->C_C[R8001]->TE_C[R2054];
  ::TE_C_mark_nested_system( te_cs:te_cs );
  select many te_cs related by ep_pkgs->PE_PE[R8000]->EP_PKG[R8001]->PE_PE[R8000]->C_C[R8001]->TE_C[R2054];
  ::TE_C_mark_nested_system( te_cs:te_cs );
  select many te_cs related by ep_pkgs->PE_PE[R8000]->CL_IC[R8001]->C_C[R4201]->TE_C[R2054];
  ::TE_C_mark_nested_system( te_cs:te_cs );
  select many te_cs related by ep_pkgs->PE_PE[R8000]->EP_PKG[R8001]->PE_PE[R8000]->CL_IC[R8001]->C_C[R4201]->TE_C[R2054];
  ::TE_C_mark_nested_system( te_cs:te_cs );
  // Uncomment the line below to use package name instead of project for the top-level files.
  //.assign te_sys.Name = "$r{package_to_build}"
else
  // Here we use the default name for the system derived from the project name.
end if;
te_file.types = ( te_sys.Name + "_" ) + te_file.types;
te_file.sys_main = ( te_sys.Name + "_" ) + te_file.sys_main;
//
// Select "Imported" Packages and link them to their imports to the
// appropriate component.
// Imported packages are empty packages imbedded within components
// that have the name of the target package as their description.
// Get the components that are part of the project.
select many te_cs from instances of TE_C where ( selected.included_in_build );
select many c_cs related by te_cs->C_C[R2054];
for each c_c in c_cs
  // Get the packages contained in this component.
  select many ep_pkgs related by c_c->PE_PE[R8003]->EP_PKG[R8001];
  for each ep_pkg in ep_pkgs
    // Get the packages that are empty (having no elements inside).
    select any pe_pe related by ep_pkg->PE_PE[R8000];
    if ( empty pe_pe )
      // We found an empty package, now check to see if it is marked as imported.
      if ( "" != ep_pkg.Descrip )
        select any imported_ep_pkg from instances of EP_PKG where ( selected.Name == ep_pkg.Descrip );
        if ( not_empty imported_ep_pkg )
          // We found a package that has a name as specified in the embedded package Descrip.
          // Disconnect the embedded package.  Relate the imported package.
          select one s_sys related by imported_ep_pkg->S_SYS[R1401];
          if ( not_empty s_sys )
            unrelate imported_ep_pkg from s_sys across R1401;
          end if;
          select one s_sys related by imported_ep_pkg->S_SYS[R1405];
          if ( not_empty s_sys )
            unrelate imported_ep_pkg from s_sys across R1405;
          end if;
          select one pe_pe related by ep_pkg->PE_PE[R8001];
          unrelate pe_pe from ep_pkg across R8001;
          relate pe_pe to imported_ep_pkg across R8001;
        end if;
      end if;
    end if;
  end for;
end for;
//
// Create and link the Extended model compiler instances.
// Do not fully initialize, yet.  Create and link and mark.
// These artifacts contain important naming that must propagate.
//
// Create the Generated Data Type instances and link them in.
select many s_dts from instances of S_DT;
for each s_dt in s_dts
  create object instance te_dt of TE_DT;
  relate te_dt to s_dt across R2021;
  te_dt.Name = s_dt.Name;
  te_dt.Core_Typ = -1;
  te_dt.string_format = "";
  // Link the ownership if contained in a component.
  te_c = empty_te_c;
  select one ep_pkg related by s_dt->PE_PE[R8001]->EP_PKG[R8000];
  if ( not_empty ep_pkg )
    r = ::TE_C_getContainingComponent( ep_pkg:ep_pkg );
    te_c = r;
  end if;
  if ( empty te_c )
    // Default the owner to be the system.
    te_dt.Owning_Dom_Name = te_sys.Name;
  else
    te_dt.Owning_Dom_Name = te_c.Name;
    relate te_dt to te_c across R2086;
  end if;
end for;
select any converted_bool_te_dt from instances of TE_DT where ( selected.Name == "integer" );
//
select many o_objs from instances of O_OBJ;
for each o_obj in o_objs
  te_c = empty_te_c;
  select one ep_pkg related by o_obj->PE_PE[R8001]->EP_PKG[R8000];
  r = ::TE_C_getContainingComponent( ep_pkg:ep_pkg );
  te_c = r;
  if ( not_empty te_c )
    if ( ( te_c.included_in_build ) and ( not te_c.isRealized ) )
      te_c.internal_behavior = true;
      // Create the Generated Class instance and link it to the real one.
      r1 = ::FactoryTE_CLASS( o_obj:o_obj, te_c:te_c );
      te_class = r1;
      if ( "C++" == te_target.language )
        te_class.scope = te_class.GeneratedName + "::";
      end if;
    end if;
  end if;
end for;
//
select many s_syncs from instances of S_SYNC;
for each s_sync in s_syncs
  te_c = empty_te_c;
  select one ep_pkg related by s_sync->PE_PE[R8001]->EP_PKG[R8000];
  r = ::TE_C_getContainingComponent( ep_pkg:ep_pkg );
  te_c = r;
  if ( not_empty te_c )
    if ( ( te_c.included_in_build ) and ( not te_c.isRealized ) )
      te_c.internal_behavior = true;
      // Create the Extended Function instance and link it to the real one.
      create object instance te_sync of TE_SYNC;
      relate s_sync to te_sync across R2023;
      relate te_sync to te_c across R2084;
      te_sync.Name = s_sync.Name;
      te_sync.GeneratedName = ( te_c.Name + "_" ) + te_sync.Name;
    end if;
  end if;
end for;
//
select many s_ees from instances of S_EE;
for each s_ee in s_ees
  select one ep_pkg related by s_ee->PE_PE[R8001]->EP_PKG[R8000];
  r = ::TE_C_getContainingComponent( ep_pkg:ep_pkg );
  te_c = r;
  if ( empty te_c )
    // Here we have an EE in a package outside of a component.
    create object instance te_ee of TE_EE;
    relate te_ee to s_ee across R2020;
    // Be sure we are not related to any te_c across R2085
      else
    if ( ( te_c.included_in_build ) and ( not te_c.isRealized ) )
      te_c.internal_behavior = true;
      // Create the Extended EE instance and link it to the real one.
      create object instance te_ee of TE_EE;
      relate te_ee to s_ee across R2020;
      relate te_ee to te_c across R2085;
    end if;
  end if;
end for;
//
//
// Create the low-level leaf items.
//
// Initialize information for a core data type:  the ANSI C typedef
// that the data type is known by in the generated code in both a
// normal object declaration and an event declaration and the initial
// value of the data element.
select many s_cdts from instances of S_CDT;
for each s_cdt in s_cdts
  select one te_dt related by s_cdt->S_DT[R17]->TE_DT[R2021];
  te_dt.Core_Typ = s_cdt.Core_Typ;
  te_dt.Include_File = te_file.types + ( "." + te_file.hdr_file_ext );
  if ( 0 == te_dt.Core_Typ )
    // void
    te_dt.ExtName = "void";
    te_dt.Initial_Value = "0";
    te_dt.string_format = "";
  elif ( 1 == te_dt.Core_Typ )
    // boolean
    if ( te_sys.AUTOSAR )
      te_dt.ExtName = "dt_xtUMLBoolean";
    else
      te_dt.ExtName = "bool";
    end if;
    te_dt.Initial_Value = "false";
    te_dt.string_format = "%d";
  elif ( 2 == te_dt.Core_Typ )
    // integer
    if ( te_sys.AUTOSAR )
      te_dt.ExtName = "dt_xtUMLInteger";
    else
      te_dt.ExtName = "i_t";
    end if;
    te_dt.Initial_Value = "0";
    te_dt.string_format = "%d";
  elif ( 3 == te_dt.Core_Typ )
    // real
    // float or double:  Default to smaller type for embedded.
    // This can be expanded with the TagDatatypePrecision marking.
    if ( te_sys.AUTOSAR )
      te_dt.ExtName = "dt_xtUMLReal";
    else
      te_dt.ExtName = "r_t";
    end if;
    te_dt.Initial_Value = "0.0";
    te_dt.string_format = "%f";
  elif ( 4 == te_dt.Core_Typ )
    // string
    te_dt.ExtName = "c_t";
    if ( te_sys.InstanceLoading )
      te_dt.ExtName = "c_t *";
    end if;
    te_dt.Initial_Value = "CTOR";
    te_dt.string_format = "%s";
  elif ( 5 == te_dt.Core_Typ )
    // unique_id
    te_dt.ExtName = te_prefix.type + "UniqueID_t";
    te_dt.Initial_Value = "0";
    te_dt.string_format = "%p";
    //
  elif ( 6 == te_dt.Core_Typ )
    // current_state
    te_dt.ExtName = "";
    te_dt.Initial_Value = "";
    te_dt.string_format = "%d";
  elif ( 7 == te_dt.Core_Typ )
    // same as base<Attribute>
    te_dt.ExtName = "";
    te_dt.Initial_Value = "";
    te_dt.string_format = "%p";
  elif ( 8 == te_dt.Core_Typ )
    // inst_ref<Object>
    te_dt.ExtName = "void *";
    te_dt.Initial_Value = "";
    te_dt.string_format = "%p";
  elif ( 9 == te_dt.Core_Typ )
    // inst_ref_set<Object>
    te_dt.ExtName = te_set.base_class + " *";
    te_dt.Initial_Value = "";
    te_dt.string_format = "%p";
  elif ( 10 == te_dt.Core_Typ )
    // inst<Event>
    te_dt.ExtName = te_eq.base_event_type + " *";
    te_dt.Initial_Value = "0";
    te_dt.string_format = "%p";
    //
  elif ( 11 == te_dt.Core_Typ )
    // inst<Mapping>
    te_dt.ExtName = "";
    te_dt.Initial_Value = "";
    te_dt.string_format = "%d";
  elif ( 12 == te_dt.Core_Typ )
    // inst_ref<Mapping>
    te_dt.ExtName = "i_t";
    te_dt.Initial_Value = "0";
    te_dt.string_format = "%d";
  else
    // undefined
    te_dt.ExtName = "";
    te_dt.Initial_Value = "";
    te_dt.string_format = "%x";
  end if;
end for;
//
// Initialize information for user data types.
select many s_udts from instances of S_UDT;
for each s_udt in s_udts
  r = ::GetBaseTypeForUDT( s_udt:s_udt );
  base_s_dt = r;
  select one core_te_dt related by base_s_dt->TE_DT[R2021];
  // Given a user data type (S_UDT) and a core data type (S_CDT), set
  // the C typedef that the user data type is known by in the generated
  // code.  Also set the initial value of the attribute.
  // Note:  An initial value of "CTOR" means to run the constructor.
  select one s_dt related by s_udt->S_DT[R17];
  select one te_dt related by s_dt->TE_DT[R2021];
  te_dt.Is_Enum = false;
  te_dt.Core_Typ = core_te_dt.Core_Typ;
  te_dt.Include_File = core_te_dt.Include_File;
  te_dt.ExtName = core_te_dt.ExtName;
  te_dt.string_format = core_te_dt.string_format;
  if ( "" != s_dt.DefaultValue )
    te_dt.Initial_Value = s_dt.DefaultValue;
  else
    te_dt.Initial_Value = core_te_dt.Initial_Value;
  end if;
  //
  // CTOR is a special string used to invoke the constructor of a data
  // attribute on the initialization list of the object constructor.
  if ( s_dt.Name == "date" )
    te_dt.ExtName = te_prefix.type + "Date_t";
    te_dt.Initial_Value = "CTOR";
  elif ( s_dt.Name == "timestamp" )
    te_dt.ExtName = te_prefix.type + "TimeStamp_t";
    te_dt.Initial_Value = "CTOR";
  elif ( s_dt.Name == "inst_ref<Timer>" )
    if ( te_tim.keyed_timer_support )
      te_dt.ExtName = te_prefix.type + "Timer_t";
    else
      te_dt.ExtName = te_prefix.type + "Timer_t *";
    end if;
    te_dt.Initial_Value = "0";
  elif ( s_dt.Name == "inst_ref<StateMachine>" )
    te_dt.ExtName = "<${te_prefix.type}Object Type *>";
    te_dt.Initial_Value = "0";
  elif ( s_dt.Name == "arbitrary_id" )
    te_dt.ExtName = te_prefix.type + "UniqueID_t";
    te_dt.Initial_Value = "0";
  end if;
end for;
//
// Initialize information for enumeration data types.
select many s_edts from instances of S_EDT;
for each s_edt in s_edts
  select one s_dt related by s_edt->S_DT[R17];
  select one te_dt related by s_dt->TE_DT[R2021];
  // NOTE: We should allow the size of an enum to be colored.
  // For now use small type.
  if ( te_sys.AUTOSAR )
    te_dt.ExtName = "en_" + te_dt.Name;
  elif ( "C" == te_target.language )
    te_dt.ExtName = ( te_sys.Name + "_" ) + ( te_dt.Name + "_t" );
  else
    te_dt.ExtName = te_dt.Name + "_t";
  end if;
  // CDS We should some day pass along the EDT.
  te_dt.Core_Typ = 2;
  te_dt.Is_Enum = true;
  te_dt.Initial_Value = ( te_dt.Owning_Dom_Name + "_" ) + ( te_dt.Name + "__UNINITIALIZED__e" );
  te_dt.Value = "-1";
  te_dt.string_format = "%d";
  if ( te_dt.Owning_Dom_Name == "sys" )
    te_dt.Include_File = ( te_file.types + "." ) + te_file.hdr_file_ext;
  end if;
  //
  // Create the Generated Enumerators and link them to the real ones.
  select many s_enums related by s_edt->S_ENUM[R27];
  for each s_enum in s_enums
    create object instance te_enum of TE_ENUM;
    relate s_enum to te_enum across R2027;
    te_enum.Name = s_enum.Name;
    te_enum.GeneratedName = ( ( te_dt.Owning_Dom_Name + "_" ) + ( te_dt.Name + "_" ) ) + ( T::r(s:te_enum.Name) + "_e" );
    value = T::parsekeyword(s:s_enum.Descrip,key:"value");
    if ( "" == value )
      value = T::parsekeyword(s:s_enum.Descrip,key:"Value");
      if ( "" == value )
        value = T::parsekeyword(s:s_enum.Descrip,key:"VALUE");
      end if;
    end if;
    te_enum.Value = value;
  end for;
end for;
//
// Initialize structured data types.
select many s_sdts from instances of S_SDT;
for each s_sdt in s_sdts
  select one te_dt related by s_sdt->S_DT[R17]->TE_DT[R2021];
  te_dt.ExtName = ( te_dt.Owning_Dom_Name + "_sdt_" ) + te_dt.Name;
  te_dt.string_format = "";
  select many s_mbrs related by s_sdt->S_MBR[R44];
  for each s_mbr in s_mbrs
    create object instance te_mbr of TE_MBR;
    relate s_mbr to te_mbr across R2047;
    select one mbr_te_dt related by s_mbr->S_DT[R45]->TE_DT[R2021];
    relate te_mbr to mbr_te_dt across R2068;
  end for;
  for each s_mbr in s_mbrs
    select one te_mbr related by s_mbr->TE_MBR[R2047];
    select one previous_te_mbr related by s_mbr->S_MBR[R46.''succeeds'']->TE_MBR[R2047];
    if ( not_empty previous_te_mbr )
      relate te_mbr to previous_te_mbr across R2067.''succeeds'';
    else
      // 
    end if;
    te_mbr.Name = s_mbr.Name;
    te_mbr.GeneratedName = T::r(s:s_mbr.Name);
    select many s_dims related by s_mbr->S_DIM[R53];
    array_spec = "";
    te_mbr.dimensions = cardinality s_dims;
    te_dim = empty_te_dim;
    dim_index = 0;
    while ( dim_index < te_mbr.dimensions )
      select any s_dim related by s_mbr->S_DIM[R53] where ( selected.dimensionCount == dim_index );
      r1 = ::FactoryTE_DIM( s_dim:s_dim, predecessor_te_dim:te_dim );
      te_dim = r1;
      if ( dim_index == 0 )
        relate te_dim to te_mbr across R2059;
      end if;
      array_spec = ( array_spec + "[" ) + ( T::s(i:te_dim.elementCount) + "]" );
      dim_index = dim_index + 1;
    end while;
    te_mbr.array_spec = array_spec;
    // In the C model compiler, treat strings as arrays.
    select one mbr_te_dt related by s_mbr->S_DT[R45]->TE_DT[R2021];
    if ( ( 4 == mbr_te_dt.Core_Typ ) and ( not te_sys.InstanceLoading ) )
      // string
      te_mbr.dimensions = te_mbr.dimensions + 1;
      te_mbr.array_spec = ( te_mbr.array_spec + "[" ) + ( te_string.max_string_length + "]" );
    end if;
  end for;
end for;
//
// Initialize instance reference data types.
select many s_irdts from instances of S_IRDT;
for each s_irdt in s_irdts
  select one te_dt related by s_irdt->S_DT[R17]->TE_DT[R2021];
  select one te_class related by s_irdt->O_OBJ[R123]->TE_CLASS[R2019];
  if ( s_irdt.isSet )
    te_dt.ExtName = te_set.base_class + " *";
    te_dt.Core_Typ = 21;
  else
    te_dt.Core_Typ = 20;
    if ( not_empty te_class )
      te_dt.ExtName = te_class.GeneratedName + " *";
    end if;
  end if;
end for;
//
// Update the precision of the integer and real types based on marking.
select many tm_precisions from instances of TM_PRECISION;
for each tm_precision in tm_precisions
  te_dts = empty_te_dts;
  if ( ( "*" == tm_precision.Domain ) or ( "" == tm_precision.Domain ) )
    select many te_dts from instances of TE_DT where ( selected.Name == tm_precision.DT_name );
  else
    select any te_c from instances of TE_C where ( selected.Name == tm_precision.Domain );
    select many te_dts related by te_c->TE_DT[R2086] where ( selected.Name == tm_precision.DT_name );
  end if;
  for each te_dt in te_dts
    // Only allow precision specification of core types integer
    // and real and user defined types (UDTs) that are enums
    // (including S_EDT).
    // S_CDT.Core_Typ == 2 is integer, S_CDT.Core_Typ == 3 is real
    select one s_dt related by te_dt->S_DT[R2021];
    select one s_edt related by s_dt->S_EDT[R17];
    select one s_cdt related by s_dt->S_CDT[R17];
    if ( empty s_cdt )
      select one s_udt related by s_dt->S_UDT[R17];
      if ( not_empty s_udt )
        r = ::GetBaseTypeForUDT( s_udt:s_udt );
        base_s_dt = r;
        select one s_cdt related by base_s_dt->S_CDT[R17];
      end if;
      if ( empty s_cdt )
        select one s_irdt related by s_dt->S_IRDT[R17];
        if ( empty s_irdt )
          if ( empty s_edt )
            T::print(s:"Warning:  Could not find a core data type (S_CDT) for input type.");
            T::exit(i:101);
          end if;
          // Enumeration Data Type (S_EDT) - give it a core type of integer.
          select any s_cdt from instances of S_CDT where ( selected.Core_Typ == 2 );
        else
          if ( s_irdt.isSet )
            select any s_cdt from instances of S_CDT where ( selected.Core_Typ == 9 );
          else
            select any s_cdt from instances of S_CDT where ( selected.Core_Typ == 8 );
          end if;
        end if;
      end if;
    end if;
    if ( ( s_cdt.Core_Typ == 2 ) or ( s_cdt.Core_Typ == 3 ) )
      r = ::MapUserSpecifiedDataTypePrecision( te_dt:te_dt, mapping:tm_precision.xName );
      status_error = r;
      if ( status_error )
        te_dt.ExtName = tm_precision.xName;
      end if;
      if ( ( "" != tm_precision.initial_value ) and ( empty s_edt ) )
        te_dt.Initial_Value = tm_precision.initial_value;
      end if;
    end if;
  end for;
end for;
//
// Map data types to pointers based on marking.
select many tm_pointers from instances of TM_POINTER;
for each tm_pointer in tm_pointers
  te_dts = empty_te_dts;
  if ( ( "*" == tm_pointer.Domain ) or ( "" == tm_pointer.Domain ) )
    select many te_dts from instances of TE_DT where ( selected.Name == tm_pointer.DT_name );
  else
    select any te_c from instances of TE_C where ( selected.Name == tm_pointer.Domain );
    select many te_dts related by te_c->TE_DT[R2086] where ( selected.Name == tm_pointer.DT_name );
  end if;
  for each te_dt in te_dts
    te_dt.ExtName = tm_pointer.pointer_type + " *";
    te_dt.Initial_Value = "0";
    te_dt.Include_File = tm_pointer.include_file;
    te_dt.Is_Enum = false;
    if ( 4 == te_dt.Core_Typ )
      // Change core type so that dimensions are not added to the pointer.
      te_dt.Core_Typ = -4;
    end if;
  end for;
end for;
//
// Mark enumerator discrete values (from marking).
select many tm_enumvals from instances of TM_ENUMVAL;
for each tm_enumval in tm_enumvals
  te_dts = empty_te_dts;
  if ( ( "*" == tm_enumval.Domain ) or ( "" == tm_enumval.Domain ) )
    select many te_dts from instances of TE_DT where ( selected.Name == tm_enumval.enumeration );
  else
    select any te_c from instances of TE_C where ( selected.Name == tm_enumval.Domain );
    select many te_dts related by te_c->TE_DT[R2086] where ( selected.Name == tm_enumval.enumeration );
  end if;
  for each te_dt in te_dts
    select any te_enum related by te_dt->S_DT[R2021]->S_EDT[R17]->S_ENUM[R27]->TE_ENUM[R2027] where ( selected.Name == tm_enumval.enumerator );
    if ( not_empty te_enum )
      te_enum.Value = tm_enumval.value;
    end if;
  end for;
end for;
//
// Mark enumerator default uninitialized values (from marking).
select many tm_enuminits from instances of TM_ENUMINIT;
for each tm_enuminit in tm_enuminits
  te_dts = empty_te_dts;
  if ( ( "*" == tm_enuminit.Domain ) or ( "" == tm_enuminit.Domain ) )
    select many te_dts from instances of TE_DT where ( selected.Name == tm_enuminit.enumeration );
  else
    select any te_c from instances of TE_C where ( selected.Name == tm_enuminit.Domain );
    select many te_dts related by te_c->TE_DT[R2086] where ( selected.Name == tm_enuminit.enumeration );
  end if;
  for each te_dt in te_dts
    te_dt.Value = tm_enuminit.value;
  end for;
end for;
//
// Create a string parameter that can be duplicated and used for returning string data.
select any string_te_dt from instances of TE_DT where ( selected.Name == "string" );
r3 = ::FactoryTE_PARM( s_dims:empty_s_dims, te_dt:string_te_dt, prefix:"", name:"A0xtumlsret", by_ref:0 );
te_parm = r3;
//
// Create the values and connect them to the V_VAL.
select many v_vals from instances of V_VAL;
for each v_val in v_vals
  create object instance te_val of TE_VAL;
  relate v_val to te_val across R2040;
  te_val.array_spec = "";
  te_val.dimensions = 0;
end for;
//
// Create the extended actual parameters and connect them to V_PAR.
select many v_pars from instances of V_PAR;
for each v_par in v_pars
  create object instance te_par of TE_PAR;
  te_par.Name = v_par.Name;
  te_par.By_Ref = 0;
  relate te_par to v_par across R2063;
end for;
//
// Create the Generated Parameters needed for all types of parameters.
// During this process, te_pars created above will be updated with
// By_Ref information.
// The TE_PARM instances must exist before creating the action bodies
// (for functions, operation, messages, etc).
select many s_bparms from instances of S_BPARM;
for each s_bparm in s_bparms
  select many s_dims related by s_bparm->S_DIM[R49];
  select one te_dt related by s_bparm->S_DT[R22]->TE_DT[R2021];
  r = ::FactoryTE_PARM( s_dims:s_dims, te_dt:te_dt, prefix:"p_", name:s_bparm.Name, by_ref:s_bparm.By_Ref );
  te_parm = r;
  te_parm.Descrip = s_bparm.Descrip;
  relate s_bparm to te_parm across R2028;
  select many te_pars related by s_bparm->S_BRG[R21]->ACT_BRG[R674]->V_PAR[R628]->TE_PAR[R2063] where ( selected.Name == te_parm.Name );
  for each te_par in te_pars
    te_par.By_Ref = te_parm.By_Ref;
    relate te_par to te_parm across R2091;
  end for;
  select many te_pars related by s_bparm->S_BRG[R21]->V_BRV[R828]->V_PAR[R810]->TE_PAR[R2063] where ( selected.Name == te_parm.Name );
  for each te_par in te_pars
    te_par.By_Ref = te_parm.By_Ref;
    relate te_par to te_parm across R2091;
  end for;
end for;
// Link the event parameters into order.
for each s_bparm in s_bparms
  select one te_parm related by s_bparm->TE_PARM[R2028];
  select one next_te_parm related by s_bparm->S_BPARM[R55.''precedes'']->TE_PARM[R2028];
  if ( not_empty next_te_parm )
    relate te_parm to next_te_parm across R2041.''precedes'';
  end if;
end for;
select many o_tparms from instances of O_TPARM;
for each o_tparm in o_tparms
  select many s_dims related by o_tparm->S_DIM[R121];
  select one te_dt related by o_tparm->S_DT[R118]->TE_DT[R2021];
  r = ::FactoryTE_PARM( s_dims:s_dims, te_dt:te_dt, prefix:"p_", name:o_tparm.Name, by_ref:o_tparm.By_Ref );
  te_parm = r;
  te_parm.Descrip = o_tparm.Descrip;
  relate o_tparm to te_parm across R2029;
  select many te_pars related by o_tparm->O_TFR[R117]->ACT_TFM[R673]->V_PAR[R627]->TE_PAR[R2063] where ( selected.Name == te_parm.Name );
  for each te_par in te_pars
    te_par.By_Ref = te_parm.By_Ref;
    relate te_par to te_parm across R2091;
  end for;
  select many te_pars related by o_tparm->O_TFR[R117]->V_TRV[R829]->V_PAR[R811]->TE_PAR[R2063] where ( selected.Name == te_parm.Name );
  for each te_par in te_pars
    te_par.By_Ref = te_parm.By_Ref;
    relate te_par to te_parm across R2091;
  end for;
end for;
// Link the event parameters into order.
for each o_tparm in o_tparms
  select one te_parm related by o_tparm->TE_PARM[R2029];
  select one next_te_parm related by o_tparm->O_TPARM[R124.''precedes'']->TE_PARM[R2029];
  if ( not_empty next_te_parm )
    relate te_parm to next_te_parm across R2041.''precedes'';
  end if;
end for;
select many s_sparms from instances of S_SPARM;
for each s_sparm in s_sparms
  select many s_dims related by s_sparm->S_DIM[R52];
  select one te_dt related by s_sparm->S_DT[R26]->TE_DT[R2021];
  r = ::FactoryTE_PARM( s_dims:s_dims, te_dt:te_dt, prefix:"p_", name:s_sparm.Name, by_ref:s_sparm.By_Ref );
  te_parm = r;
  te_parm.Descrip = s_sparm.Descrip;
  relate s_sparm to te_parm across R2030;
  select many te_pars related by s_sparm->S_SYNC[R24]->ACT_FNC[R675]->V_PAR[R669]->TE_PAR[R2063] where ( selected.Name == te_parm.Name );
  for each te_par in te_pars
    te_par.By_Ref = te_parm.By_Ref;
    relate te_par to te_parm across R2091;
  end for;
  select many te_pars related by s_sparm->S_SYNC[R24]->V_FNV[R827]->V_PAR[R817]->TE_PAR[R2063] where ( selected.Name == te_parm.Name );
  for each te_par in te_pars
    te_par.By_Ref = te_parm.By_Ref;
    relate te_par to te_parm across R2091;
  end for;
end for;
// Link the event parameters into order.
for each s_sparm in s_sparms
  select one te_parm related by s_sparm->TE_PARM[R2030];
  select one next_te_parm related by s_sparm->S_SPARM[R54.''precedes'']->TE_PARM[R2030];
  if ( not_empty next_te_parm )
    relate te_parm to next_te_parm across R2041.''precedes'';
  end if;
end for;
select many sm_evtdis from instances of SM_EVTDI;
for each sm_evtdi in sm_evtdis
  select many s_dims related by sm_evtdi->S_DIM[R531];
  select one te_dt related by sm_evtdi->S_DT[R524]->TE_DT[R2021];
  // Event data items are not passable By_Ref at this time.
  r = ::FactoryTE_PARM( s_dims:s_dims, te_dt:te_dt, prefix:"p_", name:sm_evtdi.Name, by_ref:0 );
  te_parm = r;
  te_parm.Descrip = sm_evtdi.Descrip;
  relate te_parm to sm_evtdi across R2031;
end for;
// Link the event parameters into order.
for each sm_evtdi in sm_evtdis
  select one te_parm related by sm_evtdi->TE_PARM[R2031];
  select one next_te_parm related by sm_evtdi->SM_EVTDI[R533.''precedes'']->TE_PARM[R2031];
  if ( not_empty next_te_parm )
    relate te_parm to next_te_parm across R2041.''precedes'';
  end if;
end for;
select many c_pps from instances of C_PP;
for each c_pp in c_pps
  select many s_dims related by c_pp->S_DIM[R4017];
  select one te_dt related by c_pp->S_DT[R4007]->TE_DT[R2021];
  c_pp_name = c_pp.Name;
  if ( "C++" == te_target.language )
    select one c_as related by c_pp->C_EP[R4006]->C_AS[R4004];
    if ( not_empty c_as )
      c_pp_name = ( c_as.Name + "_" ) + c_pp_name;
    else
      select one c_io related by c_pp->C_EP[R4006]->C_IO[R4004];
      c_pp_name = ( c_io.Name + "_" ) + c_pp_name;
    end if;
  end if;
  r = ::FactoryTE_PARM( s_dims:s_dims, te_dt:te_dt, prefix:"p_", name:c_pp_name, by_ref:c_pp.By_Ref );
  te_parm = r;
  te_parm.Descrip = c_pp.Descrip;
  relate c_pp to te_parm across R2048;
  select many spr_reps related by c_pp->C_EP[R4006]->SPR_REP[R4500];
  if ( not_empty spr_reps )
    select many te_pars related by spr_reps->SPR_RS[R4502]->ACT_SGN[R660]->V_PAR[R662]->TE_PAR[R2063] where ( selected.Name == c_pp.Name );
    for each te_par in te_pars
      te_par.By_Ref = te_parm.By_Ref;
      relate te_par to te_parm across R2091;
    end for;
    select many te_pars related by spr_reps->SPR_RO[R4502]->ACT_IOP[R657]->V_PAR[R679]->TE_PAR[R2063] where ( selected.Name == c_pp.Name );
    for each te_par in te_pars
      te_par.By_Ref = te_parm.By_Ref;
      relate te_par to te_parm across R2091;
    end for;
    select many te_pars related by spr_reps->V_MSV[R845]->V_PAR[R842]->TE_PAR[R2063] where ( selected.Name == c_pp.Name );
    for each te_par in te_pars
      te_par.By_Ref = te_parm.By_Ref;
      relate te_par to te_parm across R2091;
    end for;
  end if;
  select many spr_peps related by c_pp->C_EP[R4006]->SPR_PEP[R4501];
  if ( not_empty spr_peps )
    select many te_pars related by spr_peps->SPR_PS[R4503]->ACT_SGN[R663]->V_PAR[R662]->TE_PAR[R2063] where ( selected.Name == c_pp.Name );
    for each te_par in te_pars
      te_par.By_Ref = te_parm.By_Ref;
      relate te_par to te_parm across R2091;
    end for;
    select many te_pars related by spr_peps->SPR_PO[R4503]->ACT_IOP[R680]->V_PAR[R679]->TE_PAR[R2063] where ( selected.Name == c_pp.Name );
    for each te_par in te_pars
      te_par.By_Ref = te_parm.By_Ref;
      relate te_par to te_parm across R2091;
    end for;
    select many te_pars related by spr_peps->V_MSV[R841]->V_PAR[R842]->TE_PAR[R2063] where ( selected.Name == c_pp.Name );
    for each te_par in te_pars
      te_par.By_Ref = te_parm.By_Ref;
      relate te_par to te_parm across R2091;
    end for;
  end if;
end for;
// Link the event parameters into order.
for each c_pp in c_pps
  select one te_parm related by c_pp->TE_PARM[R2048];
  select one next_te_parm related by c_pp->C_PP[R4021.''precedes'']->TE_PARM[R2048];
  if ( not_empty next_te_parm )
    relate te_parm to next_te_parm across R2041.''precedes'';
  end if;
end for;
//
//
select any void_te_dt from instances of TE_DT where ( selected.Core_Typ == 0 );
//
// Create the port message actions.  There are four types.  Use
// a common extension class for all of them.
// Populate the extension with all of the names it will need from
// the component, interface, port and message.
select many spr_ros from instances of SPR_RO;
for each spr_ro in spr_ros
  select one spr_rep related by spr_ro->SPR_REP[R4502];
  select one te_po related by spr_rep->C_R[R4500]->C_IR[R4009]->C_PO[R4016]->TE_PO[R2044];
  select one te_c related by te_po->TE_C[R2005];
  select one c_io related by spr_rep->C_EP[R4500]->C_IO[R4004];
  select one te_dt related by c_io->S_DT[R4008]->TE_DT[R2021];
  // If we are using TLM ports, convert booleans to integers
  if ( "SystemC" == te_thread.flavor )
    if ( ( 1 == te_dt.Core_Typ ) and ( te_sys.SystemCPortsType == "TLM" ) )
      te_dt = converted_bool_te_dt;
    end if;
  end if;
  select many te_parms related by spr_rep->C_EP[R4500]->C_PP[R4006]->TE_PARM[R2048];
  r = ::FactoryTE_MACT( te_parms:te_parms, te_dt:te_dt, te_c:te_c, te_po:te_po, message_name:spr_ro.Name, subtypeKL:"SPR_RO" );
  te_mact = r;
  te_mact.Descrip = c_io.Descrip;
  te_mact.Direction = c_io.Direction;
  relate te_mact to spr_ro across R2052;
end for;
select many spr_rss from instances of SPR_RS;
for each spr_rs in spr_rss
  select one spr_rep related by spr_rs->SPR_REP[R4502];
  select one te_po related by spr_rep->C_R[R4500]->C_IR[R4009]->C_PO[R4016]->TE_PO[R2044];
  select one te_c related by te_po->TE_C[R2005];
  select one c_as related by spr_rep->C_EP[R4500]->C_AS[R4004];
  select many te_parms related by spr_rep->C_EP[R4500]->C_PP[R4006]->TE_PARM[R2048];
  r = ::FactoryTE_MACT( te_parms:te_parms, te_dt:void_te_dt, te_c:te_c, te_po:te_po, message_name:spr_rs.Name, subtypeKL:"SPR_RS" );
  te_mact = r;
  te_mact.Descrip = c_as.Descrip;
  te_mact.Direction = c_as.Direction;
  relate te_mact to spr_rs across R2053;
end for;
select many spr_pos from instances of SPR_PO;
for each spr_po in spr_pos
  select one spr_pep related by spr_po->SPR_PEP[R4503];
  select one te_po related by spr_pep->C_P[R4501]->C_IR[R4009]->C_PO[R4016]->TE_PO[R2044];
  select one te_c related by te_po->TE_C[R2005];
  select one c_io related by spr_pep->C_EP[R4501]->C_IO[R4004];
  select one te_dt related by c_io->S_DT[R4008]->TE_DT[R2021];
  // If we are using TLM ports, convert booleans to integers
  if ( "SystemC" == te_thread.flavor )
    if ( ( 1 == te_dt.Core_Typ ) and ( te_sys.SystemCPortsType == "TLM" ) )
      te_dt = converted_bool_te_dt;
    end if;
  end if;
  select many te_parms related by spr_pep->C_EP[R4501]->C_PP[R4006]->TE_PARM[R2048];
  r = ::FactoryTE_MACT( te_parms:te_parms, te_dt:te_dt, te_c:te_c, te_po:te_po, message_name:spr_po.Name, subtypeKL:"SPR_PO" );
  te_mact = r;
  te_mact.Descrip = c_io.Descrip;
  te_mact.Direction = c_io.Direction;
  relate te_mact to spr_po across R2050;
end for;
select many spr_pss from instances of SPR_PS;
for each spr_ps in spr_pss
  select one spr_pep related by spr_ps->SPR_PEP[R4503];
  select one te_po related by spr_pep->C_P[R4501]->C_IR[R4009]->C_PO[R4016]->TE_PO[R2044];
  select one te_c related by te_po->TE_C[R2005];
  select one c_as related by spr_pep->C_EP[R4501]->C_AS[R4004];
  select many te_parms related by spr_pep->C_EP[R4501]->C_PP[R4006]->TE_PARM[R2048];
  r = ::FactoryTE_MACT( te_parms:te_parms, te_dt:void_te_dt, te_c:te_c, te_po:te_po, message_name:spr_ps.Name, subtypeKL:"SPR_PS" );
  te_mact = r;
  te_mact.Descrip = c_as.Descrip;
  te_mact.Direction = c_as.Direction;
  relate te_mact to spr_ps across R2051;
end for;
// All the te_pos and te_macts are created now.  Order the te_macts alphabetically inside the ports.
select many te_pos from instances of TE_PO;
for each te_po in te_pos
  select many te_macts related by te_po->TE_MACT[R2006];
  r = ::mact_sort( te_macts:te_macts );
  te_mact = r;
  if ( not_empty te_mact )
    relate te_po to te_mact across R2099;
  end if;
end for;
//
//
// Create the generated links (associations) and connect them.
select many r_rels from instances of R_REL;
for each r_rel in r_rels
  create object instance te_rel of TE_REL;
  te_rel.Numb = r_rel.Numb;
  if ( te_sys.InstanceLoading )
    te_rel.LinkNeeded = true;
  else
    te_rel.LinkNeeded = false;
  end if;
  te_rel.UnlinkNeeded = false;
  te_rel.Navigated = false;
  te_rel.Order = 0;
  te_rel.storage_needed = false;
  relate r_rel to te_rel across R2034;
end for;
//
// Create the navigations and connect them to the R_OIRs.
select many r_oirs from instances of R_OIR;
for each r_oir in r_oirs
  create object instance te_oir of TE_OIR;
  select one o_obj related by r_oir->O_OBJ[R201];
  select one r_rel related by r_oir->R_REL[R201];
  te_oir.data_member = ( o_obj.Key_Lett + "_R" ) + T::s(i:r_rel.Numb);
  te_oir.assoc_type = "";
  te_oir.Mult = 0;
  te_oir.rel_phrase = "";
  te_oir.object_id = "";
  te_oir.NavigatedTo = false;
  relate r_oir to te_oir across R2035;
end for;
select many r_parts related by r_rels->R_SIMP[R206]->R_PART[R207];
for each r_part in r_parts
  select one te_oir related by r_part->R_RTO[R204]->R_OIR[R203]->TE_OIR[R2035];
  te_oir.assoc_type = "part";
  te_oir.rel_phrase = T::underscore(s:r_part.Txt_Phrs);
  te_oir.Mult = r_part.Mult;
  if ( "" != te_oir.rel_phrase )
    te_oir.data_member = ( te_oir.data_member + "_" ) + te_oir.rel_phrase;
  end if;
end for;
select many r_forms from instances of R_FORM;
for each r_form in r_forms
  select one te_oir related by r_form->R_RGO[R205]->R_OIR[R203]->TE_OIR[R2035];
  te_oir.assoc_type = "form";
  te_oir.rel_phrase = T::underscore(s:r_form.Txt_Phrs);
  te_oir.Mult = r_form.Mult;
  if ( "" != te_oir.rel_phrase )
    te_oir.data_member = ( te_oir.data_member + "_" ) + te_oir.rel_phrase;
  end if;
end for;
select many r_aones from instances of R_AONE;
for each r_aone in r_aones
  select one te_oir related by r_aone->R_RTO[R204]->R_OIR[R203]->TE_OIR[R2035];
  te_oir.assoc_type = "aone";
  te_oir.rel_phrase = T::underscore(s:r_aone.Txt_Phrs);
  te_oir.Mult = r_aone.Mult;
  if ( "" != te_oir.rel_phrase )
    te_oir.data_member = ( te_oir.data_member + "_" ) + te_oir.rel_phrase;
  end if;
end for;
select many r_aoths from instances of R_AOTH;
for each r_aoth in r_aoths
  select one te_oir related by r_aoth->R_RTO[R204]->R_OIR[R203]->TE_OIR[R2035];
  te_oir.assoc_type = "aoth";
  te_oir.rel_phrase = T::underscore(s:r_aoth.Txt_Phrs);
  te_oir.Mult = r_aoth.Mult;
  if ( "" != te_oir.rel_phrase )
    te_oir.data_member = ( te_oir.data_member + "_" ) + te_oir.rel_phrase;
  end if;
end for;
select many r_assrs from instances of R_ASSR;
for each r_assr in r_assrs
  select one te_oir related by r_assr->R_RGO[R205]->R_OIR[R203]->TE_OIR[R2035];
  te_oir.assoc_type = "assr";
  te_oir.Mult = r_assr.Mult;
end for;
select many r_subs from instances of R_SUB;
for each r_sub in r_subs
  select one te_oir related by r_sub->R_RGO[R205]->R_OIR[R203]->TE_OIR[R2035];
  select one r_rel related by r_sub->R_SUBSUP[R213]->R_REL[R206];
  te_oir.assoc_type = "subsuper";
  te_oir.object_id = ( "R" + T::s(i:r_rel.Numb) ) + "_object_id";
  te_oir.data_member = ( "R" + T::s(i:r_rel.Numb) ) + "_subtype";
end for;
select many r_supers from instances of R_SUPER;
for each r_super in r_supers
  select one te_oir related by r_super->R_RTO[R204]->R_OIR[R203]->TE_OIR[R2035];
  te_oir.assoc_type = "subsuper";
end for;
//
// Create the blocks and connect them to the ACT_BLKs.
select many act_blks from instances of ACT_BLK;
for each act_blk in act_blks
  create object instance te_blk of TE_BLK;
  relate act_blk to te_blk across R2016;
    te_blk.declaration = "";
  te_blk.deallocation = "";
  te_blk.depth = 1;
  first_smt = true;
  // Create the statements and connect them to the ACT_SMTs.
  select many act_smts related by act_blk->ACT_SMT[R602];
  for each act_smt in act_smts
    create object instance te_smt of TE_SMT;
    relate act_smt to te_smt across R2038;
    // Connect the statement to its parent block.
    relate te_smt to te_blk across R2078;
    if ( first_smt )
      // CDS WARNING!! This assumes the gen_erate will give us the first statement first!
      relate te_blk to te_smt across R2014;
      first_smt = false;
    end if;
    te_smt.OAL = "";
    te_smt.buffer = "";
    te_smt.buffer2 = "";
    te_smt.trace = "";
          end for;
  // Link the te_smts into order like the act_smts.
  for each act_smt in act_smts
    select one te_smt related by act_smt->TE_SMT[R2038];
    select one next_act_smt related by act_smt->ACT_SMT[R661.''precedes''];
    if ( not_empty next_act_smt )
      select one next_te_smt related by next_act_smt->TE_SMT[R2038];
      relate te_smt to next_te_smt across R2012.''precedes'';
    end if;
  end for;
end for;
//
// Connect up statements and blocks in the extended subsystem.
// We want statements to know:
// 1) containing block
// 2) sub-block
// [for, while, if, elif and else statements have sub-blocks.]
select many act_fors from instances of ACT_FOR;
for each act_for in act_fors
  select one te_smt related by act_for->ACT_SMT[R603]->TE_SMT[R2038];
  select one te_blk related by act_for->ACT_BLK[R605]->TE_BLK[R2016];
  relate te_smt to te_blk across R2015;
  te_smt.subtypeKL = "TE_FOR";
end for;
select many act_whls from instances of ACT_WHL;
for each act_whl in act_whls
  select one te_smt related by act_whl->ACT_SMT[R603]->TE_SMT[R2038];
  select one te_blk related by act_whl->ACT_BLK[R608]->TE_BLK[R2016];
  relate te_smt to te_blk across R2015;
  te_smt.subtypeKL = "TE_WHL";
end for;
select many act_ifs from instances of ACT_IF;
for each act_if in act_ifs
  select one te_smt related by act_if->ACT_SMT[R603]->TE_SMT[R2038];
  select one te_blk related by act_if->ACT_BLK[R607]->TE_BLK[R2016];
  relate te_smt to te_blk across R2015;
  te_smt.subtypeKL = "TE_IF";
end for;
select many act_els from instances of ACT_EL;
for each act_el in act_els
  select one te_smt related by act_el->ACT_SMT[R603]->TE_SMT[R2038];
  select one te_blk related by act_el->ACT_BLK[R658]->TE_BLK[R2016];
  relate te_smt to te_blk across R2015;
  te_smt.subtypeKL = "TE_EL";
end for;
select many act_es from instances of ACT_E;
for each act_e in act_es
  select one te_smt related by act_e->ACT_SMT[R603]->TE_SMT[R2038];
  select one te_blk related by act_e->ACT_BLK[R606]->TE_BLK[R2016];
  relate te_smt to te_blk across R2015;
  te_smt.subtypeKL = "TE_E";
end for;
// Calculate the block depth to be used for indentation.
select many te_blks from instances of TE_BLK;
for each te_blk in te_blks
  select one parent_te_blk related by te_blk->TE_SMT[R2015]->TE_BLK[R2078];
  while ( not_empty parent_te_blk )
    te_blk.depth = te_blk.depth + 1;
    select one parent_te_blk related by parent_te_blk->TE_SMT[R2015]->TE_BLK[R2078];
  end while;
  r = ::blk_indentwhitespace( indentation:te_blk.depth );
  te_blk.indentation = r;
end for;
//
// Create the generated chain links and connect them to the ACT_LNKs.
select many act_lnks from instances of ACT_LNK;
for each act_lnk in act_lnks
  ::FactoryTE_LNK( act_lnk:act_lnk );
end for;
// Link the chain links together in extensions as in meta-model proper.
select many te_lnks from instances of TE_LNK;
for each te_lnk in te_lnks
  select one act_lnk related by te_lnk->ACT_LNK[R2042];
  select one next_act_lnk related by act_lnk->ACT_LNK[R604.''precedes''];
  if ( not_empty next_act_lnk )
    select one next_te_lnk related by next_act_lnk->TE_LNK[R2042];
    relate te_lnk to next_te_lnk across R2075.''precedes'';
    // We populate this here.  Populate firsts during statement linkage.
    next_te_lnk.left = te_lnk.linkage;
    // We may have traversed directly from aoth to aone (or vice versa)
    // across an associative association.  If so, insert the associative
    // link between the two ends to enable the traversal.
    r = ::detect_and_insert_associator_TE_LNK( te_lnk:te_lnk, next_te_lnk:next_te_lnk, act_lnk:act_lnk, next_act_lnk:next_act_lnk, start_o_obj:empty_o_obj );
    discard = r;
  else
    // We can detect the end of the chain here.
    // We will detect the beginning during statement linkage.
    if ( not_empty te_lnk )
      te_lnk.last = true;
    end if;
  end if;
end for;
//
// Create the variables and connect them to the V_VAR.
select many v_vars from instances of V_VAR;
for each v_var in v_vars
  create object instance te_var of TE_VAR;
  relate v_var to te_var across R2039;
  if ( "self" == T::l(s:v_var.Name) )
    te_var.OAL = "self";
    te_var.buffer = te_instance.self;
  else
    te_var.OAL = v_var.Name;
    te_var.buffer = T::underscore(s:v_var.Name);
    if ( "C++" == te_target.language )
      // This prepends characters to transients in case the modeler used a C keyword.
      te_var.buffer = "v_" + te_var.buffer;
    end if;
  end if;
  array_spec = "";
  select many s_dims related by v_var->S_DIM[R849];
  te_var.dimensions = cardinality s_dims;
  te_dim = empty_te_dim;
  dim_index = 0;
  while ( dim_index < te_var.dimensions )
    select any s_dim related by v_var->S_DIM[R849] where ( selected.dimensionCount == dim_index );
    r = ::FactoryTE_DIM( s_dim:s_dim, predecessor_te_dim:te_dim );
    te_dim = r;
    if ( dim_index == 0 )
      relate te_dim to te_var across R2057;
    end if;
    array_spec = ( array_spec + "[" ) + ( T::s(i:te_dim.elementCount) + "]" );
    dim_index = dim_index + 1;
  end while;
  te_var.array_spec = array_spec;
  select one te_dt related by v_var->S_DT[R848]->TE_DT[R2021];
  if ( not_empty te_dt )
    // In the C model compiler, treat strings as arrays.
    if ( ( 4 == te_dt.Core_Typ ) and ( not te_sys.InstanceLoading ) )
      // string
      te_var.dimensions = te_var.dimensions + 1;
      te_var.array_spec = ( te_var.array_spec + "[" ) + ( te_string.max_string_length + "]" );
    end if;
  else
    msg = ( "\nERROR:  Did not find a datatype associated with variable " + v_var.Name ) + ".\n";
    msg = msg + "Check usages of variable for parse errors in the action language.\n";
    msg = msg + "[Parse All Activies and look for errors in the Problems view.]\n";
    T::print(s:"${msg}");
  end if;
end for;
//
//
//
// Continue initializing the components created and linked above.
// Recurse down into the component-level artifacts.
select many te_cs from instances of TE_C where ( selected.included_in_build );
for each te_c in te_cs
  // Initialize the te_sync instances.
  select many te_syncs related by te_c->TE_SYNC[R2084];
  r = ::sync_sort( te_syncs:te_syncs );
  te_sync = r;
  if ( not_empty te_sync )
    relate te_c to te_sync across R2097;
  end if;
  for each te_sync in te_syncs
    select one s_sync related by te_sync->S_SYNC[R2023];
    te_sync.IsInitFunction = false;
    te_sync.IsSafeForInterrupts = false;
    te_sync.XlateSemantics = true;
    te_sync.deferred_method = te_sync.GeneratedName + "_deferred";
    select any tm_sync from instances of TM_SYNC where ( ( selected.RegisteredDomain == te_c.Name ) and ( selected.Name == te_sync.Name ) );
    if ( not_empty tm_sync )
      te_sync.IsSafeForInterrupts = tm_sync.IsSafeForInterrupts;
      select one rval_dt related by s_sync->S_DT[R25];
      if ( rval_dt.Name != "void" )
        T::print(s:"ERROR:  Function ${te_sync.Name} in ${te_c.Name}");
        T::print(s:"is trying to return data.  Functions marked as safe for");
        T::print(s:"interrupt invocation cannot return data.  They must be");
        T::print(s:"of return type void.");
        T::print(s:"Change the return type of the function or do not mark");
        T::print(s:"it as SafeForInterrupts.");
        T::exit(i:100);
      end if;
    end if;
    if ( te_sync.IsSafeForInterrupts )
      te_sync.intraface_method = te_sync.GeneratedName + "_sync";
    else
      te_sync.intraface_method = te_sync.GeneratedName;
    end if;
    select one te_dt related by s_sync->S_DT[R25]->TE_DT[R2021];
    select many te_parms related by s_sync->S_SPARM[R24]->TE_PARM[R2030];
    r1 = ::FactoryTE_ABA( te_c:te_c, te_parms:te_parms, scope:te_c.Name, name:te_sync.GeneratedName, subtypeKL:"S_SYNC", te_dt:te_dt );
    te_aba = r1;
    relate te_sync to te_aba across R2010;
    select one te_blk related by s_sync->ACT_FNB[R695]->ACT_ACT[R698]->ACT_BLK[R666]->TE_BLK[R2016];
    if ( not_empty te_blk )
      relate te_blk to te_aba across R2011;
    end if;
  end for;
  //
  // Create the Generated External Entity instances and link them in.
  select many te_ees related by te_c->TE_EE[R2085];
  for each te_ee in te_ees
    ::TE_EE_init( te_ee:te_ee, te_c:te_c );
  end for;
  r1 = ::ee_sort( te_ees:te_ees );
  te_ee = r1;
  if ( not_empty te_ee )
    relate te_c to te_ee across R2098;
  end if;
  //
  select many te_macts related by te_c->TE_MACT[R2002];
  for each te_mact in te_macts
    select one te_aba related by te_mact->TE_ABA[R2010];
    select any te_blk from instances of TE_BLK where ( false );
    if ( "SPR_PO" == te_mact.subtypeKL )
      select one te_blk related by te_mact->SPR_PO[R2050]->ACT_POB[R687]->ACT_ACT[R698]->ACT_BLK[R666]->TE_BLK[R2016];
    elif ( "SPR_RO" == te_mact.subtypeKL )
      select one te_blk related by te_mact->SPR_RO[R2052]->ACT_ROB[R685]->ACT_ACT[R698]->ACT_BLK[R666]->TE_BLK[R2016];
    elif ( "SPR_PS" == te_mact.subtypeKL )
      select one te_blk related by te_mact->SPR_PS[R2051]->ACT_PSB[R686]->ACT_ACT[R698]->ACT_BLK[R666]->TE_BLK[R2016];
    elif ( "SPR_RS" == te_mact.subtypeKL )
      select one te_blk related by te_mact->SPR_RS[R2053]->ACT_RSB[R684]->ACT_ACT[R698]->ACT_BLK[R666]->TE_BLK[R2016];
    end if;
    if ( not_empty te_blk )
      relate te_blk to te_aba across R2011;
    end if;
  end for;
  //
  // Initialize the Generated Class instances.
  select many te_classs related by te_c->TE_CLASS[R2064];
  for each te_class in te_classs
    select one o_obj related by te_class->O_OBJ[R2019];
    // Initialize model compiler extension attributes.
    te_class.SelfCreated = false;
    te_class.NonSelfCreated = false;
    te_class.Included = false;
    te_class.IsFixedPopulation = false;
    te_class.PEIsDefinedInData = false;
    te_class.IsReadOnly = false;
    // Default is 10 instances per class.
    te_class.MaxExtentSize = 10;
    te_class.Persistent = false;
    te_class.ExcludeFromGen = false;
    te_class.IsTrace = true;
    te_class.ContainerIndex = 0;
    te_class.Task = 0;
    te_class.class_file = te_class.GeneratedName + "_class";
    te_class.system_class_number = te_class.GeneratedName + "_CLASS_NUMBER";
    te_class.CBsystem_class_number = te_class.GeneratedName + "_CLASS_NUMBER_CB";
    te_class.dispatcher = "";
    te_class.CBdispatcher = "";
    select one sm_ism related by o_obj->SM_ISM[R518];
    if ( not_empty sm_ism )
      te_class.dispatcher = te_class.GeneratedName + "_Dispatch";
    end if;
    select one sm_asm related by o_obj->SM_ASM[R519];
    if ( not_empty sm_asm )
      te_class.CBdispatcher = te_class.GeneratedName + "_CBDispatch";
    end if;
    te_class.persist_link = te_class.GeneratedName + "_LinkCentral";
    //
    // Create the Generated Attribute instances and link them to the real ones.
    delimiter = "";
    prev_te_attr = empty_te_attr;
    // Find first o_attr.
    select any o_attr related by o_obj->O_ATTR[R102];
    while ( not_empty o_attr )
      select one prev_o_attr related by o_attr->O_ATTR[R103.''succeeds''];
      if ( empty prev_o_attr )
        break;
      end if;
      o_attr = prev_o_attr;
    end while;
    while ( not_empty o_attr )
      create object instance te_attr of TE_ATTR;
      te_attr.Name = o_attr.Name;
      te_attr.GeneratedName = T::r(s:o_attr.Name);
      te_attr.DefaultValue = o_attr.DefaultValue;
      te_attr.Used = false;
      te_attr.read = false;
      te_attr.written = false;
      te_attr.Included = false;
      te_attr.Order = 0;
      te_attr.ParamBuffer = "";
      te_attr.translate = true;
      relate te_attr to o_attr across R2033;
      relate te_attr to te_class across R2061;
            if ( not_empty prev_te_attr )
        relate prev_te_attr to te_attr across R2087.''precedes'';
      end if;
      select many s_dims related by o_attr->S_DIM[R120];
      array_spec = "";
      te_attr.dimensions = cardinality s_dims;
      te_dim = empty_te_dim;
      dim_index = 0;
      while ( dim_index < te_attr.dimensions )
        select any s_dim related by o_attr->S_DIM[R120] where ( selected.dimensionCount == dim_index );
        r2 = ::FactoryTE_DIM( s_dim:s_dim, predecessor_te_dim:te_dim );
        te_dim = r2;
        if ( dim_index == 0 )
          relate te_dim to te_attr across R2055;
        end if;
        array_spec = ( array_spec + "[" ) + ( T::s(i:te_dim.elementCount) + "]" );
        dim_index = dim_index + 1;
      end while;
      te_attr.array_spec = array_spec;
      select one te_dt related by o_attr->S_DT[R114]->TE_DT[R2021];
      // Potentially substitute data type for base attribute data type.
      if ( 7 == te_dt.Core_Typ )
        // referential attribute
        r2 = ::GetAttributeCodeGenType( o_attr:o_attr );
        te_dt = r2;
      end if;
      te_attr.GeneratedType = te_dt.ExtName;
      o_attr_Descrip_Persistent = T::parsekeyword(s:o_attr.Descrip,key:"Persistent");
      if ( o_attr_Descrip_Persistent != "false" )
        if ( "%p" == te_dt.string_format )
          te_class.attribute_format = ( te_class.attribute_format + delimiter ) + "%ld";
          te_class.attribute_dump = ( te_class.attribute_dump + ",\n    ((long)self->" ) + ( te_attr.GeneratedName + " & ESCHER_IDDUMP_MASK)" );
        elif ( "%s" == te_dt.string_format )
          // Place an escaped tick mark around the %s in the attribute format string.
          te_class.attribute_format = ( ( te_class.attribute_format + delimiter ) + ( "''''" + te_dt.string_format ) ) + "''''";
          te_class.attribute_dump = ( ( ( te_class.attribute_dump + ",\n    ( 0 != self->" ) + ( te_attr.GeneratedName + " ) ? self->" ) ) + ( ( te_attr.GeneratedName + " : " ) + "" ) );
        else
          te_class.attribute_format = ( te_class.attribute_format + delimiter ) + te_dt.string_format;
          te_class.attribute_dump = ( te_class.attribute_dump + ",\n    self->" ) + te_attr.GeneratedName;
        end if;
      end if;
      // In the C model compiler, treat strings as arrays.
      if ( ( 4 == te_dt.Core_Typ ) and ( not te_sys.InstanceLoading ) )
        // string
        te_attr.dimensions = te_attr.dimensions + 1;
        te_attr.array_spec = ( te_attr.array_spec + "[" ) + ( te_string.max_string_length + "]" );
      end if;
      //
      // Create the Action Block Anchors associated with each action
      // in the user model.  Initialize and link them.
      // Create and link the Generated versions of each of the action homes.
      select one o_dbattr related by o_attr->O_BATTR[R106]->O_DBATTR[R107];
      if ( not_empty o_dbattr )
        create object instance te_dbattr of TE_DBATTR;
        te_dbattr.Included = false;
        te_dbattr.GeneratedName = ( te_class.GeneratedName + "_MDA_" ) + o_attr.Name;
        relate o_dbattr to te_dbattr across R2026;
        select one te_dt related by o_attr->S_DT[R114]->TE_DT[R2021];
        te_parms = empty_te_parms;
        r2 = ::FactoryTE_ABA( te_c:te_c, te_parms:te_parms, scope:"", name:te_dbattr.GeneratedName, subtypeKL:"O_DBATTR", te_dt:te_dt );
        te_aba = r2;
        relate te_dbattr to te_aba across R2010;
        select one te_blk related by o_dbattr->ACT_DAB[R693]->ACT_ACT[R698]->ACT_BLK[R666]->TE_BLK[R2016];
        if ( not_empty te_blk )
          relate te_blk to te_aba across R2011;
        end if;
      end if;
      delimiter = ",";
      prev_te_attr = te_attr;
      select one o_attr related by o_attr->O_ATTR[R103.''precedes''];
    end while;
    //
    // Create the Generated State Machines and connect them to SM_SM.
    select one sm_sm related by o_obj->SM_ISM[R518]->SM_SM[R517];
    if ( not_empty sm_sm )
      ::FactoryTE_SM( is_ism:true, sm_sm:sm_sm, te_class:te_class );
    end if;
    select one sm_sm related by o_obj->SM_ASM[R519]->SM_SM[R517];
    if ( not_empty sm_sm )
      ::FactoryTE_SM( is_ism:false, sm_sm:sm_sm, te_class:te_class );
    end if;
    //
    // Create and relate the generated class operations.
    select many o_tfrs related by o_obj->O_TFR[R115];
    for each o_tfr in o_tfrs
      create object instance te_tfr of TE_TFR;
      te_tfr.Included = false;
      te_tfr.XlateSemantics = true;
      ib = Scope::Instance;
      if ( ib == o_tfr.Instance_Based )
        te_tfr.Instance_Based = 1;
      else
        te_tfr.Instance_Based = 0;
      end if;
      te_tfr.Key_Lett = te_class.Key_Lett;
      te_tfr.Name = o_tfr.Name;
      te_tfr.GeneratedName = ( ( te_c.Name + "_" ) + ( te_tfr.Key_Lett + "_op_" ) ) + te_tfr.Name;
      relate o_tfr to te_tfr across R2024;
      select one te_dt related by o_tfr->S_DT[R116]->TE_DT[R2021];
      select many te_parms related by o_tfr->O_TPARM[R117]->TE_PARM[R2029];
      r2 = ::FactoryTE_ABA( te_c:te_c, te_parms:te_parms, scope:te_class.GeneratedName, name:te_tfr.GeneratedName, subtypeKL:"O_TFR", te_dt:te_dt );
      te_aba = r2;
      relate te_tfr to te_aba across R2010;
      select one te_blk related by o_tfr->ACT_OPB[R696]->ACT_ACT[R698]->ACT_BLK[R666]->TE_BLK[R2016];
      if ( not_empty te_blk )
        relate te_blk to te_aba across R2011;
      end if;
    end for;
    //
    // Create the WhereKey instance connected to O_ID.
    select many o_ids related by o_obj->O_ID[R104];
    for each o_id in o_ids
      create object instance te_where of TE_WHERE;
      te_where.WhereKey = false;
      relate te_where to o_id across R2032;
      number = te_where.Oid_ID + 1;
      te_where.select_any_where = ( te_class.GeneratedName + "_AnyWhere" ) + T::s(i:number);
    end for;
  end for;
end for;
//
select many te_ees from instances of TE_EE;
for each te_ee in te_ees
  select one te_c related by te_ee->TE_C[R2085];
  if ( empty te_c )
    ::TE_EE_init( te_ee:te_ee, te_c:empty_te_c );
  end if;
end for;
//
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO PE_PE
	VALUES ("0b057462-c85f-4f46-b529-07122c615f4a",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("aa7a279a-d058-4d1f-9859-e2696c391363",
	"00000000-0000-0000-0000-000000000000",
	'FactoryTE_CLASS',
	'',
	'//
//
//============================================================================
// New and return instance of TE_CLASS.
//============================================================================
o_obj = param.o_obj;
te_c = param.te_c;
// Create the Generated Class instance and link it to the model one.
create object instance te_class of TE_CLASS;
relate te_class to o_obj across R2019;
relate te_class to te_c across R2064;
// Copy the Numb attribute for sorting purposes.
te_class.Numb = o_obj.Numb;
// Copy other attributes for convenience so we can avoid accessing o_obj.
te_class.Name = o_obj.Name;
te_class.Key_Lett = o_obj.Key_Lett;
te_class.Key_Lett = T::r(s:te_class.Key_Lett);
// Initialize model compiler extension attributes.
te_class.GeneratedName = ( te_c.Name + "_" ) + te_class.Key_Lett;
te_class.CBGeneratedName = te_class.GeneratedName + "_CB";
te_class.scope = "";
te_class.attribute_format = "";
return te_class;
',
	"a4c72a7c-2bdb-49fd-8096-759f23d860e2",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("634ba773-ae46-4180-9b9d-fe7978d3302c",
	"aa7a279a-d058-4d1f-9859-e2696c391363",
	'o_obj',
	"63f4ff99-f127-443b-a678-30ace41da702",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("a4db529a-17b8-427f-82b9-1e35301d36c4",
	"aa7a279a-d058-4d1f-9859-e2696c391363",
	'te_c',
	"1a67c2f6-b8b4-421a-a4f5-d999e2cdd281",
	0,
	'',
	"634ba773-ae46-4180-9b9d-fe7978d3302c",
	'');
INSERT INTO PE_PE
	VALUES ("aa7a279a-d058-4d1f-9859-e2696c391363",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("99a70631-c48e-4864-9a5d-4a0395c1e6b5",
	"00000000-0000-0000-0000-000000000000",
	'FactoryTE_DIM',
	'',
	'//
//
//============================================================================
// New and return instance of TE_DIM.
//============================================================================
s_dim = param.s_dim;
predecessor_te_dim = param.predecessor_te_dim;
create object instance te_dim of TE_DIM;
te_dim.elementCount = s_dim.elementCount;
if ( 0 == te_dim.elementCount )
  // Here we have a VLA (variable length array).
  // Add support here.
end if;
te_dim.dimensionCount = s_dim.dimensionCount;
if ( not_empty predecessor_te_dim )
  relate te_dim to predecessor_te_dim across R2060.''succeeds'';
end if;
return te_dim;
',
	"5ee47065-5cc5-4da1-a87d-6b0d76386786",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("fecdcff6-8b49-406f-a00b-1547ce0cf324",
	"99a70631-c48e-4864-9a5d-4a0395c1e6b5",
	's_dim',
	"fe657de0-5197-484d-8944-ee29b57152d4",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("fe657de0-5197-484d-8944-ee29b57152d4",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Dimensions>',
	'',
	'',
	'../../ooaofooa/Domain/Domain.xtuml');
INSERT INTO S_SPARM
	VALUES ("3e4b42ad-aab2-4cbe-9b52-0a516c323478",
	"99a70631-c48e-4864-9a5d-4a0395c1e6b5",
	'predecessor_te_dim',
	"5ee47065-5cc5-4da1-a87d-6b0d76386786",
	0,
	'',
	"fecdcff6-8b49-406f-a00b-1547ce0cf324",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("5ee47065-5cc5-4da1-a87d-6b0d76386786",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Extended Dimension>',
	'',
	'',
	'../../ooaofooa/Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("99a70631-c48e-4864-9a5d-4a0395c1e6b5",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("24081a09-0451-45b6-95f0-2195a5c5ca7b",
	"00000000-0000-0000-0000-000000000000",
	'FactoryTE_SM',
	'',
	'//
//
//============================================================================
// New and link state machine instances.
// Allocate and link state instances (in numerically sorted order).
//============================================================================
is_ism = param.is_ism;
sm_sm = param.sm_sm;
te_class = param.te_class;
select any void_te_dt from instances of TE_DT where ( selected.Core_Typ == 0 );
select many empty_te_parms from instances of TE_PARM where ( false );
select one te_c related by te_class->TE_C[R2064];
create object instance te_sm of TE_SM;
relate te_sm to te_class across R2072;
relate te_sm to sm_sm across R2043;
te_sm.complete = false;
class_based = "_CB";
if ( is_ism )
  class_based = "";
end if;
te_sm.SEMname = ( te_class.GeneratedName + class_based ) + "_StateEventMatrix";
te_sm.state_names_array = ( "state_name_strings" + class_based );
te_sm.action_array = ( te_class.GeneratedName + class_based ) + "_acts";
te_sm.txn_action_array = ( te_class.GeneratedName + class_based ) + "_xacts";
te_sm.action_type = "StateAction_t";
te_sm.events_union = ( te_class.GeneratedName + class_based ) + "_Events_u";
//
// Create the Generated States and connect them to SM_STATE.
select many sm_states related by sm_sm->SM_STATE[R501];
te_sm.num_states = cardinality sm_states;
for each sm_state in sm_states
  create object instance te_state of TE_STATE;
  te_state.Name = sm_state.Name;
  te_state.Numb = sm_state.Numb;
  relate te_state to sm_state across R2037;
  te_state.enumerator = ( te_class.GeneratedName + class_based ) + ( "_STATE_" + T::s(i:te_state.Numb) );
  //
  // Create the Extended Actions (TE_ACT) and connect them to SM_ACT.
  select one sm_act related by sm_state->SM_MOAH[R511]->SM_AH[R513]->SM_ACT[R514];
  create object instance te_act of TE_ACT;
  relate sm_act to te_act across R2022;
  te_act.GeneratedName = ( te_class.GeneratedName + class_based ) + ( "_act" + T::s(i:te_state.Numb) );
  //.select many te_parms related by sm_state->SM_SEME[R503]->SM_SEVT[R503]->SM_EVT[R525]->SM_EVTDI[R532]->TE_PARM[R2031]
  r = ::FactoryTE_ABA( te_c:te_c, te_parms:empty_te_parms, scope:"", name:te_act.GeneratedName, subtypeKL:"SM_ACT", te_dt:void_te_dt );
  te_aba = r;
  relate te_act to te_aba across R2010;
  select one te_blk related by sm_act->ACT_SAB[R691]->ACT_ACT[R698]->ACT_BLK[R666]->TE_BLK[R2016];
  if ( not_empty te_blk )
    relate te_blk to te_aba across R2011;
  end if;
end for;
//
// Sort the states for later state event matrix generation.
select many te_states related by sm_states->TE_STATE[R2037];
//   Sort the instances in the instance set <item_set> in ascending numeric
// order, based on the value of the Numb (integer) attribute value of
// each instance. The Order (integer) attribute value of each instance will
// be set to contain a value relative to Numb, indicating the position
// the instance has in the ordered set.
//   This function is definately *slow*, but will work with any objects
// which contain integer attributes <Numb> and <Order>.
item_set = te_states;
//
// Clear the Order attribute of all set members.
for each item in item_set
  item.Order = 0;
end for;
// simple pseudo bubble sort
item_set_copy = item_set;
for each item in item_set
  for each item_copy in item_set_copy
    if ( item_copy.Numb > item.Numb )
      item_copy.Order = item_copy.Order + 1;
    end if;
  end for;
end for;
for each te_state in te_states
  te_state.number = te_state.Order + 1;
  if ( 0 == te_state.Order )
    te_sm.initial_state = te_state.enumerator;
  end if;
end for;
//
// Create the actions for the transitions.
counter = 1;
// This is the hairiest traversal we do.  We are finding actions
// that actually have action language.
select many sm_acts related by sm_sm->SM_TXN[R505]->SM_TAH[R530]->SM_AH[R513]->SM_ACT[R514]->ACT_TAB[R688]->ACT_ACT[R698]->ACT_BLK[R666]->ACT_SMT[R602]->ACT_BLK[R602]->ACT_ACT[R666]->ACT_TAB[R698]->SM_ACT[R688];
for each sm_act in sm_acts
  // Create the Extended Actions (TE_ACT) and connect them to SM_ACT.
  create object instance te_act of TE_ACT;
  relate sm_act to te_act across R2022;
  select one sm_state related by sm_act->SM_AH[R514]->SM_TAH[R513]->SM_TXN[R530]->SM_STATE[R506];
  te_act.GeneratedName = ( ( te_class.GeneratedName + class_based ) + ( "_xact_to_" + T::s(i:sm_state.Numb) ) ) + ( "_" + T::s(i:counter) );
  te_act.number = counter;
  //.select many te_parms related by sm_act->SM_AH[R514]->SM_TAH[R513]->SM_TXN[R530]->SM_NSTXN[R507]->SM_SEME[R504]->SM_SEVT[R503]->SM_EVT[R525]->SM_EVTDI[R532]->TE_PARM[R2031]
  r = ::FactoryTE_ABA( te_c:te_c, te_parms:empty_te_parms, scope:"", name:te_act.GeneratedName, subtypeKL:"SM_ACT", te_dt:void_te_dt );
  te_aba = r;
  relate te_act to te_aba across R2010;
  select one te_blk related by sm_act->ACT_TAB[R688]->ACT_ACT[R698]->ACT_BLK[R666]->TE_BLK[R2016];
  if ( not_empty te_blk )
    relate te_blk to te_aba across R2011;
  end if;
  counter = counter + 1;
end for;
te_sm.txn_action_count = counter - 1;
//
// Create the Generated Events and connect them to SM_EVT.
select many sm_evts related by sm_sm->SM_EVT[R502];
te_sm.num_events = cardinality sm_evts;
for each sm_evt in sm_evts
  create object instance te_evt of TE_EVT;
  relate te_evt to te_sm across R2071;
  te_evt.Name = sm_evt.Mning;
  te_evt.Numb = sm_evt.Numb;
  te_evt.Order = 0;
  te_evt.Used = false;
  te_evt.UsedCount = 0;
  te_evt.Priority = 0;
  relate te_evt to sm_evt across R2036;
  suffix = T::s(i:te_evt.Numb);
  select one sm_nlevt related by sm_evt->SM_SEVT[R525]->SM_NLEVT[R526];
  if ( not_empty sm_nlevt )
    // Non local event defined by a polymorphic event
    select one super_sm_evt related by sm_nlevt->SM_PEVT[R527]->SM_EVT[R525];
    select one super_obj related by super_sm_evt->SM_SM[R502]->SM_ISM[R517]->O_OBJ[R518];
    suffix = ( "_" + T::r(s:super_obj.Key_Lett) ) + ( "_PE" + T::s(i:super_sm_evt.Numb) );
  end if;
  te_evt.GeneratedName = ( te_class.GeneratedName + class_based ) + ( "event" + suffix );
  te_evt.Enumerator = T::u(s:te_evt.GeneratedName) + "NUM";
end for;
// Select the local events (only in this state machine), the "true" events
// (land here but also seen as polys) and polymorphic events.  Order the
// events starting with local then true then polys.
select many sm_levts related by sm_sm->SM_EVT[R502]->SM_SEVT[R525]->SM_LEVT[R526];
select many local_te_evts related by sm_levts->SM_SEVT[R526]->SM_EVT[R525]->TE_EVT[R2036];
//   Sort the instances in the instance set <item_set> in ascending numeric
// order, based on the value of the Numb (integer) attribute value of
// each instance. The Order (integer) attribute value of each instance will
// be set to contain a value relative to Numb, indicating the position
// the instance has in the ordered set.
//   This function is definately *slow*, but will work with any objects
// which contain integer attributes <Numb> and <Order>.
item_set1 = local_te_evts;
//
// Clear the Order attribute of all set members.
for each item1 in item_set1
  item1.Order = 0;
end for;
// simple pseudo bubble sort
item_set1_copy = item_set1;
for each item1 in item_set1
  for each item1_copy in item_set1_copy
    if ( item1_copy.Numb > item1.Numb )
      item1_copy.Order = item1_copy.Order + 1;
    end if;
  end for;
end for;
last_event_number = cardinality local_te_evts;
last_event_number = last_event_number - 1;
select many sm_sgevts related by sm_sm->SM_EVT[R502]->SM_SEVT[R525]->SM_SGEVT[R526];
select many signal_te_evts related by sm_sgevts->SM_SEVT[R526]->SM_EVT[R525]->TE_EVT[R2036];
for each te_evt in signal_te_evts
  // Mark signals as used to be sure we get code.
  te_evt.Used = true;
  te_evt.UsedCount = 1;
  last_event_number = last_event_number + 1;
  te_evt.Order = last_event_number;
  // Link each signal te_mact to its associated signal te_evts.
  select one te_mact related by te_evt->SM_EVT[R2036]->SM_SEVT[R525]->SM_SGEVT[R526]->SPR_PS[R528]->TE_MACT[R2051];
  if ( empty te_mact )
    select one te_mact related by te_evt->SM_EVT[R2036]->SM_SEVT[R525]->SM_SGEVT[R526]->SPR_RS[R529]->TE_MACT[R2053];
  end if;
  if ( not_empty te_mact )
    relate te_mact to te_evt across R2082;
  end if;
end for;
select many sm_nlevts related by sm_sm->SM_EVT[R502]->SM_SEVT[R525]->SM_NLEVT[R526];
select many true_te_evts related by sm_nlevts->SM_SEVT[R526]->SM_EVT[R525]->TE_EVT[R2036];
for each te_evt in true_te_evts
  // Mark polys and non-locals as used to be sure we get code.
  te_evt.Used = true;
  te_evt.UsedCount = 1;
  last_event_number = last_event_number + 1;
  te_evt.Order = last_event_number;
end for;
// Finally, order the polymorphic events.
// We need their Order to be greater than local and true events, since
// polys are not state event matrix events.
select many poly_te_evts related by sm_sm->SM_EVT[R502]->SM_PEVT[R525]->SM_EVT[R525]->TE_EVT[R2036];
for each te_evt in poly_te_evts
  // Mark polys and non-locals as used to be sure we get code.
  te_evt.Used = true;
  te_evt.UsedCount = 1;
  last_event_number = last_event_number + 1;
  te_evt.Order = last_event_number;
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("b83f3888-6b6e-4927-af81-51cdedceba55",
	"24081a09-0451-45b6-95f0-2195a5c5ca7b",
	'is_ism',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("6014106d-87e6-4648-a748-b68f00f76d15",
	"24081a09-0451-45b6-95f0-2195a5c5ca7b",
	'sm_sm',
	"f6562655-0940-4f4f-a1ae-7094b79949a7",
	0,
	'',
	"b83f3888-6b6e-4927-af81-51cdedceba55",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("f6562655-0940-4f4f-a1ae-7094b79949a7",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<State Machine>',
	'',
	'',
	'../../ooaofooa/State Machine/State Machine.xtuml');
INSERT INTO S_SPARM
	VALUES ("5b28e420-b38c-4a2e-b909-8d6a6f54b65a",
	"24081a09-0451-45b6-95f0-2195a5c5ca7b",
	'te_class',
	"a4c72a7c-2bdb-49fd-8096-759f23d860e2",
	0,
	'',
	"6014106d-87e6-4648-a748-b68f00f76d15",
	'');
INSERT INTO PE_PE
	VALUES ("24081a09-0451-45b6-95f0-2195a5c5ca7b",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("f97c30a7-b326-4e76-b98f-a87aaad3d546",
	"00000000-0000-0000-0000-000000000000",
	'FactoryTE_MACT',
	'',
	'//
//
//============================================================================
// New and link message actions.
//============================================================================
te_parms = param.te_parms;
te_dt = param.te_dt;
te_c = param.te_c;
te_po = param.te_po;
message_name = param.message_name;
subtypeKL = param.subtypeKL;
select any te_file from instances of TE_FILE;
select any te_sys from instances of TE_SYS;
select any te_target from instances of TE_TARGET;
select any te_thread from instances of TE_THREAD;
create object instance te_mact of TE_MACT;
relate te_mact to te_c across R2002;
relate te_mact to te_po across R2006;
// We cannot just look to see if this port is polymorphic, we have to go to the
// associated interface and see if any port tied to that interface is polymorphic.
// TODO - We would like to move this -up- and handle it when the ports are created,
//   perhaps use 2081 for the satisfaction.
select one c_i related by te_po->C_I[R2007];
select any te_po_poly related by c_i->TE_PO[R2007] where ( ( selected.Provision == te_po.Provision ) and selected.polymorphic );
if ( empty te_po_poly )
  te_mact.polymorphic = false;
else
  te_mact.polymorphic = true;
end if;
te_mact.subtypeKL = subtypeKL;
te_mact.Provision = te_po.Provision;
te_mact.MessageName = message_name;
te_mact.InterfaceName = te_po.InterfaceName;
te_mact.PortName = te_po.GeneratedName;
te_mact.ComponentName = te_c.Name;
te_mact.GeneratedName = ( ( te_mact.ComponentName + "_" ) + ( te_mact.PortName + "_" ) ) + message_name;
if ( "C++" == te_target.language )
  te_mact.GeneratedName = ( te_mact.InterfaceName + "_" ) + message_name;
end if;
te_mact.GeneratedName = T::r(s:te_mact.GeneratedName);
te_mact.Name = te_mact.GeneratedName;
select any converted_bool_te_dt from instances of TE_DT where ( selected.Name == "integer" );
if ( ( "SystemC" == te_thread.flavor ) and ( te_sys.SystemCPortsType == "TLM" ) )
  for each te_parm in te_parms
    // If we are using TLM ports, convert booleans to integers
    select one param_te_dt related by te_parm->TE_DT[R2049];
    if ( 1 == param_te_dt.Core_Typ )
      relate te_parm to converted_bool_te_dt across R2049;
    end if;
  end for;
end if;
if ( ( te_mact.polymorphic ) and ( "SystemC" == te_thread.flavor ) )
  // If polymorphic, then add a parameter that we can use to distinguish 
  // which port the message came in through.
  select many s_dims from instances of S_DIM where ( false );
  select any portindex_te_dt from instances of TE_DT where ( selected.Name == "integer" );
  r1 = ::FactoryTE_PARM( s_dims:s_dims, te_dt:portindex_te_dt, prefix:"", name:"A00portindex", by_ref:0 );
  polymorphic_te_parm = r1;
  polymorphic_te_parm.Descrip = "architectural port selector";
  for each te_parm in te_parms
    if ( 0 == te_parm.Order )
      relate polymorphic_te_parm to te_parm across R2041.''precedes'';
    end if;
  end for;
  te_parms = te_parms;
end if;
r = ::FactoryTE_ABA( te_c:te_c, te_parms:te_parms, scope:te_mact.ComponentName, name:te_mact.GeneratedName, subtypeKL:"TE_MACT", te_dt:te_dt );
te_aba = r;
relate te_mact to te_aba across R2010;
return te_mact;
',
	"026512d0-8760-4cb8-9267-673322497da6",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("212be91f-c447-4c80-94a2-ba3ad5770dea",
	"f97c30a7-b326-4e76-b98f-a87aaad3d546",
	'te_parms',
	"70195573-bee1-46b0-a3f6-afce8594f5f5",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("693b88d2-cea0-4522-8de9-63a39ee90710",
	"f97c30a7-b326-4e76-b98f-a87aaad3d546",
	'te_dt',
	"b38f65e4-3751-44ac-a43f-142a02d52c3a",
	0,
	'',
	"212be91f-c447-4c80-94a2-ba3ad5770dea",
	'');
INSERT INTO S_SPARM
	VALUES ("acec2b79-cc56-463f-aa56-497495130675",
	"f97c30a7-b326-4e76-b98f-a87aaad3d546",
	'te_c',
	"1a67c2f6-b8b4-421a-a4f5-d999e2cdd281",
	0,
	'',
	"693b88d2-cea0-4522-8de9-63a39ee90710",
	'');
INSERT INTO S_SPARM
	VALUES ("3f31ff5f-9a89-4e9a-9da3-c879177ca884",
	"f97c30a7-b326-4e76-b98f-a87aaad3d546",
	'te_po',
	"d303200c-a4c1-4436-8fd1-9f684c9509a9",
	0,
	'',
	"acec2b79-cc56-463f-aa56-497495130675",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("d303200c-a4c1-4436-8fd1-9f684c9509a9",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Extended Port>',
	'',
	'',
	'../../ooaofooa/Translation Extensions/Translation Extensions.xtuml');
INSERT INTO S_SPARM
	VALUES ("19cd87ac-15f7-456b-88ca-deb4fb270a9a",
	"f97c30a7-b326-4e76-b98f-a87aaad3d546",
	'message_name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"3f31ff5f-9a89-4e9a-9da3-c879177ca884",
	'');
INSERT INTO S_SPARM
	VALUES ("365defcc-dd85-44cf-9906-fbc42e1a55e8",
	"f97c30a7-b326-4e76-b98f-a87aaad3d546",
	'subtypeKL',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"19cd87ac-15f7-456b-88ca-deb4fb270a9a",
	'');
INSERT INTO PE_PE
	VALUES ("f97c30a7-b326-4e76-b98f-a87aaad3d546",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_DT_PROXY
	VALUES ("026512d0-8760-4cb8-9267-673322497da6",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Extended Message Action>',
	'',
	'',
	'../../ooaofooa/Translation Extensions/Translation Extensions.xtuml');
INSERT INTO S_SYNC
	VALUES ("c78c47f1-7136-4c4c-ac79-67cdefea1b42",
	"00000000-0000-0000-0000-000000000000",
	'TE_EE_init',
	'',
	'//
//============================================================================
// Initialize instance of TE_EE.
//============================================================================
te_ee = param.te_ee;
te_c = param.te_c;
select any te_file from instances of TE_FILE;
select any te_target from instances of TE_TARGET;
component_scope = "";
if ( not_empty te_c )
  component_scope = te_c.Name + "_";
end if;
select one s_ee related by te_ee->S_EE[R2020];
// Default the registered name to be the key letters.
// Bridge wiring will override this default, but the default may
// allow the code to compile.
te_ee.Name = s_ee.Name;
te_ee.Descrip = s_ee.Descrip;
te_ee.Key_Lett = s_ee.Key_Lett;
te_ee.RegisteredName = component_scope + T::r(s:te_ee.Key_Lett);
te_ee.Included = false;
te_ee.Used = false;
te_ee.file = te_ee.RegisteredName + "_bridge";
// Leave alone if marked.
if ( "" == te_ee.Include_File )
  te_ee.Include_File = te_ee.file + ( "." + te_file.hdr_file_ext );
end if;
if ( "TIM" == s_ee.Key_Lett )
  // Time (TIM) EE
  te_ee.RegisteredName = "TIM";
  te_ee.Include_File = te_file.tim + ( "." + te_file.hdr_file_ext );
end if;
bridge_scope = "";
if ( "C" == te_target.language )
  bridge_scope = te_ee.RegisteredName + "_";
end if;
select many s_brgs related by s_ee->S_BRG[R19];
for each s_brg in s_brgs
  create object instance te_brg of TE_BRG;
  relate te_brg to s_brg across R2025;
  relate te_brg to te_ee across R2089;
  te_brg.EEkeyletters = s_ee.Key_Lett;
  te_brg.EEname = s_ee.Name;
  te_brg.Name = s_brg.Name;
  te_brg.GeneratedName = bridge_scope + s_brg.Name;
  select one te_dt related by s_brg->S_DT[R20]->TE_DT[R2021];
  select many te_parms related by s_brg->S_BPARM[R21]->TE_PARM[R2028];
  r = ::FactoryTE_ABA( te_c:te_c, te_parms:te_parms, scope:te_ee.RegisteredName, name:te_brg.GeneratedName, subtypeKL:"S_BRG", te_dt:te_dt );
  te_aba = r;
  relate te_brg to te_aba across R2010;
  select one te_blk related by s_brg->ACT_BRB[R697]->ACT_ACT[R698]->ACT_BLK[R666]->TE_BLK[R2016];
  if ( not_empty te_blk )
    relate te_blk to te_aba across R2011;
  end if;
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("c78a283f-0b97-41b8-ab8f-659bdfad72fa",
	"c78c47f1-7136-4c4c-ac79-67cdefea1b42",
	'te_ee',
	"b2d4d12f-d262-45d3-b989-4d5a579921b1",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("b2d4d12f-d262-45d3-b989-4d5a579921b1",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Extended External Entity>',
	'',
	'',
	'../../ooaofooa/Translation Extensions/Translation Extensions.xtuml');
INSERT INTO S_SPARM
	VALUES ("208881db-4ec2-4713-9d25-30684dc22c17",
	"c78c47f1-7136-4c4c-ac79-67cdefea1b42",
	'te_c',
	"1a67c2f6-b8b4-421a-a4f5-d999e2cdd281",
	0,
	'',
	"c78a283f-0b97-41b8-ab8f-659bdfad72fa",
	'');
INSERT INTO PE_PE
	VALUES ("c78c47f1-7136-4c4c-ac79-67cdefea1b42",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("5f40e6fb-b0e3-4824-82bf-404a09165ca2",
	"00000000-0000-0000-0000-000000000000",
	'FactoryTE_ABA',
	'',
	'//
//============================================================================
// New and return instance of TE_ABA.
//============================================================================
te_c = param.te_c;
te_parms = param.te_parms;
scope = param.scope;
name = param.name;
subtypeKL = param.subtypeKL;
te_dt = param.te_dt;
select any te_sys from instances of TE_SYS;
select any te_target from instances of TE_TARGET;
create object instance te_aba of TE_ABA;
te_aba.SelfEventCount = 0;
te_aba.NonSelfEventCount = 0;
te_aba.subtypeKL = subtypeKL;
if ( not_empty te_c )
  relate te_aba to te_c across R2088;
end if;
duplicates_needed = false;
select any te_parm from instances of TE_PARM where ( false );
for each te_parm in te_parms
  select one existing_te_aba related by te_parm->TE_ABA[R2062];
  if ( empty existing_te_aba )
    relate te_parm to te_aba across R2062;
  else
    duplicates_needed = true;
  end if;
end for;
first_te_parm = te_parm;
if ( duplicates_needed or ( ( "c_t" == te_dt.ExtName ) or ( "c_t *" == te_dt.ExtName ) ) )
  // Find first te_parm.
  while ( not_empty te_parm )
    select one prev_te_parm related by te_parm->TE_PARM[R2041.''succeeds''];
    if ( empty prev_te_parm )
      first_te_parm = te_parm;
      break;
    else
      te_parm = prev_te_parm;
    end if;
  end while;
end if;
// This duplication is needed because multiple ports can use the same
// interface.  It would be nice to explore a method to avoid duplicating
// the parameter instances.
if ( duplicates_needed )
  select one prev_te_parm related by te_parm->TE_PARM[R2041.''succeeds''] where ( false );
  while ( not_empty te_parm )
    r = ::TE_PARM_duplicate( te_parm:te_parm );
    duplicate_te_parm = r;
    relate duplicate_te_parm to te_aba across R2062;
    if ( not_empty prev_te_parm )
      relate prev_te_parm to duplicate_te_parm across R2041.''precedes'';
    end if;
    prev_te_parm = duplicate_te_parm;
    select one te_parm related by te_parm->TE_PARM[R2041.''precedes''];
  end while;
  select many te_parms related by te_aba->TE_PARM[R2062];
end if;
// Create and insert an architectural parameter for returning a string.
if ( ( "c_t" == te_dt.ExtName ) or ( "c_t *" == te_dt.ExtName ) )
  if ( ( not te_sys.InstanceLoading ) and ( not duplicates_needed ) )
    // mcmc does not return through the by-ref parameter.
    // When duplicating, there is a duplicate by-ref string return parameter.
    select any string_te_parm from instances of TE_PARM where ( selected.Name == "A0xtumlsret" );
    r = ::TE_PARM_duplicate( te_parm:string_te_parm );
    duplicate_te_parm = r;
    duplicate_te_parm.Descrip = "xtuml string return parm";
    relate duplicate_te_parm to te_aba across R2062;
    if ( not_empty first_te_parm )
      relate duplicate_te_parm to first_te_parm across R2041.''precedes'';
    end if;
    select many te_parms related by te_aba->TE_PARM[R2062];
  end if;
end if;
::te_parm_RenderParameters( te_parms:te_parms, te_aba:te_aba );
te_aba.scope = "";
if ( "C++" == te_target.language )
  te_aba.scope = scope + "::";
  if ( not_empty te_c )
    if ( ( "S_BRG" == te_aba.subtypeKL ) or ( "O_TFR" == te_aba.subtypeKL ) )
      if ( empty te_parms )
        te_aba.ParameterDefinition = ( " " + te_c.Name ) + " * thismodule";
        te_aba.ParameterDeclaration = ( " " + te_c.Name ) + " *";
      else
        te_aba.ParameterDefinition = ( ( " " + te_c.Name ) + ( " * thismodule," + te_aba.ParameterDefinition ) );
        te_aba.ParameterDeclaration = ( ( " " + te_c.Name ) + ( " *," + te_aba.ParameterDeclaration ) );
      end if;
    end if;
  end if;
end if;
te_aba.GeneratedName = name;
te_aba.ReturnDataType = te_dt.ExtName;
te_aba.dimensions = 0;
// In the C model compiler, treat strings as arrays.
if ( ( 4 == te_dt.Core_Typ ) and ( not te_sys.InstanceLoading ) )
  // string
  select any te_string from instances of TE_STRING;
  te_aba.dimensions = te_aba.dimensions + 1;
  te_aba.array_spec = ( te_aba.array_spec + "[" ) + ( te_string.max_string_length + "]" );
end if;
// Allow arrays (including strings) to be returned as pointers.
if ( te_aba.dimensions > 0 )
  te_aba.ReturnDataType = te_aba.ReturnDataType + " *";
end if;
return te_aba;
',
	"044779c7-f309-4b44-a24c-2b497f1c2c80",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("c69c8991-7be5-4ccc-99da-fae5a16035b4",
	"5f40e6fb-b0e3-4824-82bf-404a09165ca2",
	'te_c',
	"1a67c2f6-b8b4-421a-a4f5-d999e2cdd281",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("7f84c9ae-0c79-4466-b135-5dd611fa8dc9",
	"5f40e6fb-b0e3-4824-82bf-404a09165ca2",
	'te_parms',
	"70195573-bee1-46b0-a3f6-afce8594f5f5",
	0,
	'',
	"c69c8991-7be5-4ccc-99da-fae5a16035b4",
	'');
INSERT INTO S_SPARM
	VALUES ("ce4de543-bdb8-4da4-8630-29afbce3c62d",
	"5f40e6fb-b0e3-4824-82bf-404a09165ca2",
	'scope',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"7f84c9ae-0c79-4466-b135-5dd611fa8dc9",
	'');
INSERT INTO S_SPARM
	VALUES ("155e4949-0327-4dc1-979b-d5b68d352251",
	"5f40e6fb-b0e3-4824-82bf-404a09165ca2",
	'name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"ce4de543-bdb8-4da4-8630-29afbce3c62d",
	'');
INSERT INTO S_SPARM
	VALUES ("4deab243-4965-44da-8d69-da9f5c93b0d4",
	"5f40e6fb-b0e3-4824-82bf-404a09165ca2",
	'subtypeKL',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"155e4949-0327-4dc1-979b-d5b68d352251",
	'');
INSERT INTO S_SPARM
	VALUES ("a26826e5-6c20-468f-88c3-8377d74d56b8",
	"5f40e6fb-b0e3-4824-82bf-404a09165ca2",
	'te_dt',
	"b38f65e4-3751-44ac-a43f-142a02d52c3a",
	0,
	'',
	"4deab243-4965-44da-8d69-da9f5c93b0d4",
	'');
INSERT INTO PE_PE
	VALUES ("5f40e6fb-b0e3-4824-82bf-404a09165ca2",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("1ce7c214-71db-4019-8488-f73c49d576d0",
	"00000000-0000-0000-0000-000000000000",
	'FactoryTE_PARM',
	'',
	'//
//
//============================================================================
// New and link up extended parameter.
//============================================================================
s_dims = param.s_dims;
te_dt = param.te_dt;
prefix = param.prefix;
name = param.name;
by_ref = param.by_ref;
create object instance te_parm of TE_PARM;
te_parm.Order = 0;
te_parm.ParamBuffer = "";
te_parm.OALParamBuffer = "";
te_parm.Name = T::r(s:name);
te_parm.By_Ref = by_ref;
te_parm.GeneratedName = prefix + name;
relate te_parm to te_dt across R2049;
// Set up the array dimensions for the parameter.
te_parm.dimensions = cardinality s_dims;
array_spec = "";
select one te_dim related by te_parm->TE_DIM[R2056] where ( false );
dim_index = 0;
while ( dim_index < te_parm.dimensions )
  for each s_dim in s_dims
    if ( s_dim.dimensionCount == dim_index )
      r = ::FactoryTE_DIM( s_dim:s_dim, predecessor_te_dim:te_dim );
      te_dim = r;
      if ( dim_index == 0 )
        relate te_parm to te_dim across R2056;
      end if;
      array_spec = ( array_spec + "[" ) + ( T::s(i:te_dim.elementCount) + "]" );
    end if;
  end for;
  dim_index = dim_index + 1;
  te_parm.By_Ref = 0;
end while;
te_parm.array_spec = array_spec;
// In the C model compiler, treat strings as arrays.
if ( 4 == te_dt.Core_Typ )
  select any te_sys from instances of TE_SYS;
  if ( not te_sys.InstanceLoading )
    // string
    select any te_string from instances of TE_STRING;
    te_parm.dimensions = te_parm.dimensions + 1;
    te_parm.array_spec = ( te_parm.array_spec + "[" ) + ( te_string.max_string_length + "]" );
  end if;
  // strings are already by-ref
  te_parm.By_Ref = 0;
end if;
return te_parm;
',
	"7a7c55de-19e8-42d0-81a9-1d26e33982ad",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("eb89a533-ea64-4a0d-98d0-d1630f2aadee",
	"1ce7c214-71db-4019-8488-f73c49d576d0",
	's_dims',
	"9e615117-5ec7-43cc-a3c5-fe7cdd626110",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("9e615117-5ec7-43cc-a3c5-fe7cdd626110",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref_set<Dimensions>',
	'',
	'',
	'../../ooaofooa/Domain/Domain.xtuml');
INSERT INTO S_SPARM
	VALUES ("6f55fddf-e322-4c4b-9635-4584cbd8566c",
	"1ce7c214-71db-4019-8488-f73c49d576d0",
	'te_dt',
	"b38f65e4-3751-44ac-a43f-142a02d52c3a",
	0,
	'',
	"eb89a533-ea64-4a0d-98d0-d1630f2aadee",
	'');
INSERT INTO S_SPARM
	VALUES ("ff8d4d0b-184d-47c9-9ff5-69990aaad094",
	"1ce7c214-71db-4019-8488-f73c49d576d0",
	'prefix',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"6f55fddf-e322-4c4b-9635-4584cbd8566c",
	'');
INSERT INTO S_SPARM
	VALUES ("699e9644-527c-4b8d-88a5-2e96e875b446",
	"1ce7c214-71db-4019-8488-f73c49d576d0",
	'name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"ff8d4d0b-184d-47c9-9ff5-69990aaad094",
	'');
INSERT INTO S_SPARM
	VALUES ("5cb518dc-c13e-45e7-9204-85bb565e8d80",
	"1ce7c214-71db-4019-8488-f73c49d576d0",
	'by_ref',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"699e9644-527c-4b8d-88a5-2e96e875b446",
	'');
INSERT INTO PE_PE
	VALUES ("1ce7c214-71db-4019-8488-f73c49d576d0",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_DT_PROXY
	VALUES ("7a7c55de-19e8-42d0-81a9-1d26e33982ad",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Extended Parameter>',
	'',
	'',
	'../../ooaofooa/Translation Extensions/Translation Extensions.xtuml');
INSERT INTO S_SYNC
	VALUES ("c1a40b99-5b8e-44d9-9136-a864b9b9a240",
	"00000000-0000-0000-0000-000000000000",
	'TE_PARM_duplicate',
	'',
	'//
//============================================================================
// Duplicate (copy) an instance of TE_PARM.
//============================================================================
te_parm = param.te_parm;
create object instance duplicate_te_parm of TE_PARM;
duplicate_te_parm.Order = te_parm.Order;
duplicate_te_parm.ParamBuffer = te_parm.ParamBuffer;
duplicate_te_parm.OALParamBuffer = te_parm.OALParamBuffer;
duplicate_te_parm.Name = te_parm.Name;
duplicate_te_parm.Descrip = te_parm.Descrip;
duplicate_te_parm.By_Ref = te_parm.By_Ref;
duplicate_te_parm.GeneratedName = te_parm.GeneratedName;
select one te_dt related by te_parm->TE_DT[R2049];
relate duplicate_te_parm to te_dt across R2049;
duplicate_te_parm.dimensions = te_parm.dimensions;
select one te_dim related by te_parm->TE_DIM[R2056];
if ( not_empty te_dim )
  relate duplicate_te_parm to te_dim across R2056;
else
  end if;
duplicate_te_parm.array_spec = te_parm.array_spec;
return duplicate_te_parm;
',
	"7a7c55de-19e8-42d0-81a9-1d26e33982ad",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("8d3d16d9-65ee-41fe-9591-a06cb41a9288",
	"c1a40b99-5b8e-44d9-9136-a864b9b9a240",
	'te_parm',
	"7a7c55de-19e8-42d0-81a9-1d26e33982ad",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("c1a40b99-5b8e-44d9-9136-a864b9b9a240",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("b3d5de88-6ddc-4371-be59-a05514f35543",
	"00000000-0000-0000-0000-000000000000",
	'FactoryTE_LNK',
	'',
	'//
//============================================================================
// New and return instance of TE_LNK.
//============================================================================
act_lnk = param.act_lnk;
select one o_obj related by act_lnk->O_OBJ[R678];
select one te_class related by o_obj->TE_CLASS[R2019];
if ( not_empty te_class )
  create object instance te_lnk of TE_LNK;
  relate te_lnk to act_lnk across R2042;
  te_lnk.rel_phrase = act_lnk.Rel_Phrase;
    select one r_rel related by act_lnk->R_REL[R681];
  te_lnk.rel_number = r_rel.Numb;
  relate te_lnk to te_class across R2076;
  te_lnk.OAL = ( ( "->" + te_class.Key_Lett ) + ( "[R" + T::s(i:te_lnk.rel_number) ) );
  if ( "" != te_lnk.rel_phrase )
    te_lnk.OAL = ( te_lnk.OAL + "." ) + te_lnk.rel_phrase;
  end if;
  te_lnk.OAL = te_lnk.OAL + "]";
  te_lnk.first = false;
  te_lnk.last = false;
  rel_phrase = T::underscore(s:te_lnk.rel_phrase);
  select any te_oir related by r_rel->R_OIR[R201]->TE_OIR[R2035] where ( ( selected.Obj_ID == o_obj.Obj_ID ) and ( selected.rel_phrase == rel_phrase ) );
  if ( empty te_oir )
    select any te_oir related by r_rel->R_OIR[R201]->TE_OIR[R2035] where ( selected.Obj_ID == o_obj.Obj_ID );
  end if;
  te_lnk.linkage = te_oir.data_member;
  te_lnk.Mult = te_oir.Mult;
  te_lnk.assoc_type = te_oir.assoc_type;
  // Deal with associative reflexives.
  if ( "assr" == te_oir.assoc_type )
    r = ::is_reflexive( r_rel:r_rel );
    reflexive = r;
    if ( reflexive )
      select one r_aone related by r_rel->R_ASSOC[R206]->R_AONE[R209];
      select one r_aoth related by r_rel->R_ASSOC[R206]->R_AOTH[R210];
      if ( te_lnk.rel_phrase == r_aone.Txt_Phrs )
        te_lnk.Mult = r_aone.Mult;
      elif ( te_lnk.rel_phrase == r_aoth.Txt_Phrs )
        te_lnk.Mult = r_aoth.Mult;
      else
        T::print(s:"ERROR:  Unrecognized reflexive association:  R$t{r_rel.Numb}.");
        T::exit(i:13);
      end if;
      te_lnk.linkage = ( te_oir.data_member + "_" ) + rel_phrase;
    end if;
  end if;
  te_lnk.iterator = "i" + te_lnk.linkage;
end if;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("a2b494fe-4fa4-486f-970c-9fccff8097d7",
	"b3d5de88-6ddc-4371-be59-a05514f35543",
	'act_lnk',
	"bcbe8755-e8ea-4d2b-9f81-529c5437c084",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("bcbe8755-e8ea-4d2b-9f81-529c5437c084",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Chain Link>',
	'',
	'',
	'../../ooaofooa/Selection/Selection.xtuml');
INSERT INTO PE_PE
	VALUES ("b3d5de88-6ddc-4371-be59-a05514f35543",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("7099c4fb-9683-42de-9f42-26c27d8d6549",
	"00000000-0000-0000-0000-000000000000",
	'associator_TE_LNK',
	'',
	'//
//============================================================================
// Create and insert a new TE_LNK between these two (for associator).
//============================================================================
left_te_lnk = param.left_te_lnk;
right_te_lnk = param.right_te_lnk;
create object instance te_lnk of TE_LNK;
te_lnk.rel_phrase = "";
// Insert the new link in between the left and right TE_LNKs.
relate te_lnk to right_te_lnk across R2075.''precedes'';
select one r_rel related by right_te_lnk->ACT_LNK[R2042]->R_REL[R681];
te_lnk.rel_number = right_te_lnk.rel_number;
select one te_class related by r_rel->R_ASSOC[R206]->R_ASSR[R211]->R_RGO[R205]->R_OIR[R203]->O_OBJ[R201]->TE_CLASS[R2019];
relate te_lnk to te_class across R2076;
// Leave OAL blank, because real OAL is not showing this link.
te_lnk.OAL = "";
select any te_oir related by r_rel->R_OIR[R201]->R_RGO[R203]->R_OIR[R203]->TE_OIR[R2035];
te_lnk.linkage = te_oir.data_member;
te_lnk.Mult = te_oir.Mult;
te_lnk.assoc_type = te_oir.assoc_type;
// Reflexive associatives put the relationship phrase onto the AONE/AOTH data members.
if ( "" != right_te_lnk.rel_phrase )
  te_lnk.linkage = ( te_lnk.linkage + "_" ) + T::underscore(s:right_te_lnk.rel_phrase);
end if;
if ( not_empty left_te_lnk )
  relate left_te_lnk to te_lnk across R2075.''precedes'';
  te_lnk.left = left_te_lnk.linkage;
  te_lnk.first = false;
else
  te_lnk.left = te_lnk.linkage;
  te_lnk.first = true;
end if;
te_lnk.last = false;
te_lnk.iterator = "i" + te_lnk.linkage;
te_lnk.Mult = right_te_lnk.Mult;
right_te_lnk.Mult = 0;
right_te_lnk.left = te_lnk.linkage;
return te_lnk;
',
	"23d94a7d-e6b1-4eec-a9cf-06f461733cad",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("745c2178-f144-444e-9dad-bb9ed2134a81",
	"7099c4fb-9683-42de-9f42-26c27d8d6549",
	'left_te_lnk',
	"23d94a7d-e6b1-4eec-a9cf-06f461733cad",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("23d94a7d-e6b1-4eec-a9cf-06f461733cad",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Extended Chain Link>',
	'',
	'',
	'../../ooaofooa/Translation OAL/Translation OAL.xtuml');
INSERT INTO S_SPARM
	VALUES ("8c8578e4-fbe2-4ada-9022-a83aa6480c98",
	"7099c4fb-9683-42de-9f42-26c27d8d6549",
	'right_te_lnk',
	"23d94a7d-e6b1-4eec-a9cf-06f461733cad",
	0,
	'',
	"745c2178-f144-444e-9dad-bb9ed2134a81",
	'');
INSERT INTO PE_PE
	VALUES ("7099c4fb-9683-42de-9f42-26c27d8d6549",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("92c6e4aa-f670-4b2c-b32d-944378c8f99f",
	"00000000-0000-0000-0000-000000000000",
	'detect_and_insert_associator_TE_LNK',
	'',
	'//
//============================================================================
// Detect and insert an associator TE_LNK if needed and adjust the te_lnk
// attributes according to the flavor of associative traversal.
// Accept a pair of te_lnk instances or a start_o_obj and one next_te_lnk.
//============================================================================
te_lnk = param.te_lnk;
next_te_lnk = param.next_te_lnk;
act_lnk = param.act_lnk;
next_act_lnk = param.next_act_lnk;
start_o_obj = param.start_o_obj;
if ( not_empty te_lnk )
  select one start_o_obj related by act_lnk->O_OBJ[R678];
end if;
if ( "aone" == next_te_lnk.assoc_type )
  select one r_aoth related by next_act_lnk->R_REL[R681]->R_ASSOC[R206]->R_AOTH[R210];
  if ( start_o_obj.Obj_ID == r_aoth.Obj_ID )
    // aoth -> aone
    r = ::associator_TE_LNK( left_te_lnk:te_lnk, right_te_lnk:next_te_lnk );
    te_lnk = r;
  else
    select one r_assr related by next_act_lnk->R_REL[R681]->R_ASSOC[R206]->R_ASSR[R211];
    if ( start_o_obj.Obj_ID == r_assr.Obj_ID )
      // assr -> aone
      next_te_lnk.Mult = 0;
    end if;
  end if;
elif ( "aoth" == next_te_lnk.assoc_type )
  select one r_aone related by next_act_lnk->R_REL[R681]->R_ASSOC[R206]->R_AONE[R209];
  if ( start_o_obj.Obj_ID == r_aone.Obj_ID )
    // aone -> aoth
    r = ::associator_TE_LNK( left_te_lnk:te_lnk, right_te_lnk:next_te_lnk );
    te_lnk = r;
  else
    select one r_assr related by next_act_lnk->R_REL[R681]->R_ASSOC[R206]->R_ASSR[R211];
    if ( start_o_obj.Obj_ID == r_assr.Obj_ID )
      // assr -> aoth
      next_te_lnk.Mult = 0;
    end if;
  end if;
elif ( "assr" == next_te_lnk.assoc_type )
  // For an associator, the multiplicity is that of the far side.
  select one r_aone related by next_act_lnk->R_REL[R681]->R_ASSOC[R206]->R_AONE[R209];
  select one r_aoth related by next_act_lnk->R_REL[R681]->R_ASSOC[R206]->R_AOTH[R210];
  if ( r_aone.Obj_ID == r_aoth.Obj_ID )
    // reflexive associative going from aone/aoth to assr
    if ( r_aone.Txt_Phrs == next_te_lnk.rel_phrase )
      next_te_lnk.Mult = r_aone.Mult;
    elif ( r_aoth.Txt_Phrs == next_te_lnk.rel_phrase )
      next_te_lnk.Mult = r_aoth.Mult;
    else
      T::print(s:"Invalid associative reflexive traversal from ${start_o_obj.Name}/${start_o_obj.Key_Lett} to ${next_te_lnk.te_classGeneratedName}.");
      T::exit(i:100);
    end if;
  elif ( start_o_obj.Obj_ID == r_aone.Obj_ID )
    // aone -> assr
    next_te_lnk.Mult = r_aoth.Mult;
  elif ( start_o_obj.Obj_ID == r_aoth.Obj_ID )
    // aoth -> assr
    next_te_lnk.Mult = r_aone.Mult;
  else
    T::print(s:"Invalid associative reflexive traversal from ${start_o_obj.Name}/${start_o_obj.Key_Lett} to ${next_te_lnk.te_classGeneratedName}.");
    T::exit(i:100);
  end if;
end if;
return te_lnk;
',
	"23d94a7d-e6b1-4eec-a9cf-06f461733cad",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("362eef48-c85f-46e5-bb44-eb7b4a384165",
	"92c6e4aa-f670-4b2c-b32d-944378c8f99f",
	'te_lnk',
	"23d94a7d-e6b1-4eec-a9cf-06f461733cad",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("b2288ee7-5009-426f-9b29-80fb3aae6cf8",
	"92c6e4aa-f670-4b2c-b32d-944378c8f99f",
	'next_te_lnk',
	"23d94a7d-e6b1-4eec-a9cf-06f461733cad",
	0,
	'',
	"362eef48-c85f-46e5-bb44-eb7b4a384165",
	'');
INSERT INTO S_SPARM
	VALUES ("0e9952ad-5841-479f-858d-8d28e9bc4b89",
	"92c6e4aa-f670-4b2c-b32d-944378c8f99f",
	'act_lnk',
	"bcbe8755-e8ea-4d2b-9f81-529c5437c084",
	0,
	'',
	"b2288ee7-5009-426f-9b29-80fb3aae6cf8",
	'');
INSERT INTO S_SPARM
	VALUES ("3bfa49f0-8fda-4b94-81aa-7671470a4a04",
	"92c6e4aa-f670-4b2c-b32d-944378c8f99f",
	'next_act_lnk',
	"bcbe8755-e8ea-4d2b-9f81-529c5437c084",
	0,
	'',
	"0e9952ad-5841-479f-858d-8d28e9bc4b89",
	'');
INSERT INTO S_SPARM
	VALUES ("8411fd72-88f8-424c-85b1-63d6b29498ff",
	"92c6e4aa-f670-4b2c-b32d-944378c8f99f",
	'start_o_obj',
	"63f4ff99-f127-443b-a678-30ace41da702",
	0,
	'',
	"3bfa49f0-8fda-4b94-81aa-7671470a4a04",
	'');
INSERT INTO PE_PE
	VALUES ("92c6e4aa-f670-4b2c-b32d-944378c8f99f",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("40827b24-7bf6-46fc-9dfc-748c7230d8ca",
	"00000000-0000-0000-0000-000000000000",
	'TE_C_mark_nested_system',
	'',
	'//
// Recursive call to drill down and get all of the nested components and
// component references.
te_cs = param.te_cs;
for each te_c in te_cs
  te_c.included_in_build = true;
  select many nested_te_cs related by te_c->C_C[R2054]->PE_PE[R8003]->C_C[R8001]->TE_C[R2054];
  ::TE_C_mark_nested_system( te_cs:nested_te_cs );
  select many nested_te_cs related by te_c->C_C[R2054]->PE_PE[R8003]->CL_IC[R8001]->C_C[R4201]->TE_C[R2054];
  ::TE_C_mark_nested_system( te_cs:nested_te_cs );
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("197613d9-0641-4466-a3b5-0391e288e936",
	"40827b24-7bf6-46fc-9dfc-748c7230d8ca",
	'te_cs',
	"e95ad139-5ff9-4970-b88f-913d324aa2aa",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("e95ad139-5ff9-4970-b88f-913d324aa2aa",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref_set<Extended Component>',
	'',
	'',
	'../../ooaofooa/Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("40827b24-7bf6-46fc-9dfc-748c7230d8ca",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("977d6b62-3780-4eec-9483-f737d37c7e45",
	"00000000-0000-0000-0000-000000000000",
	'TE_C_getContainingComponent',
	'',
	'//
// Recursively search upwards through the package hierarchy to find the
// containing (parent/owning) component.
ep_pkg = param.ep_pkg;
select any te_c from instances of TE_C where ( false );
// Return empty te_c for a top-level package with no containing package or component.
select one s_sys related by ep_pkg->S_SYS[R1401];
if ( empty s_sys )
  select one te_c related by ep_pkg->PE_PE[R8001]->C_C[R8003]->TE_C[R2054];
  if ( empty te_c )
    select one parent_ep_pkg related by ep_pkg->PE_PE[R8001]->EP_PKG[R8000];
    if ( not_empty parent_ep_pkg )
      r = ::TE_C_getContainingComponent( ep_pkg:parent_ep_pkg );
      te_c = r;
    end if;
  end if;
end if;
return te_c;
',
	"1a67c2f6-b8b4-421a-a4f5-d999e2cdd281",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("db79f250-226e-4c9b-9296-0186807328fc",
	"977d6b62-3780-4eec-9483-f737d37c7e45",
	'ep_pkg',
	"9939c670-a721-4742-a824-ed4b0df4acd6",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("9939c670-a721-4742-a824-ed4b0df4acd6",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Package>',
	'',
	'',
	'../../ooaofooa/Instance Reference Data Types/Instance Reference Data Types.xtuml');
INSERT INTO PE_PE
	VALUES ("977d6b62-3780-4eec-9483-f737d37c7e45",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("596851e0-11db-443d-b03d-0279261bbda5",
	"00000000-0000-0000-0000-000000000000",
	'EP_PKG_getContainingPackage',
	'',
	'//
// Recursively search upwards through the component hierarcy to find the
// containing (parent/owning) package.
c_c = param.c_c;
select one ep_pkg related by c_c->PE_PE[R8001]->EP_PKG[R8000];
if ( empty ep_pkg )
  select one c_c related by c_c->PE_PE[R8001]->C_C[R8003];
  r = ::EP_PKG_getContainingPackage( c_c:c_c );
  ep_pkg = r;
end if;
return ep_pkg;
',
	"9939c670-a721-4742-a824-ed4b0df4acd6",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("18f2bc7e-1805-42c9-b338-7d305077c41c",
	"596851e0-11db-443d-b03d-0279261bbda5",
	'c_c',
	"67f93d18-1045-4c6c-b0d5-a692023c471c",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("67f93d18-1045-4c6c-b0d5-a692023c471c",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Component>',
	'',
	'',
	'../../ooaofooa/Instance Reference Data Types/Instance Reference Data Types.xtuml');
INSERT INTO PE_PE
	VALUES ("596851e0-11db-443d-b03d-0279261bbda5",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("1a525e2a-6e59-4d43-bef1-ed2354919d36",
	"00000000-0000-0000-0000-000000000000",
	'TE_C_sort',
	'',
	'//
// Sort a list of TE_Cs.
te_cs = param.te_cs;
// Declare an empty instance reference.
select any head_te_c related by te_cs->TE_C[R2017.''precedes''] where ( false );
for each te_c in te_cs
  r = ::TE_C_insert( head_te_c:head_te_c, te_c:te_c );
  head_te_c = r;
end for;
return head_te_c;
',
	"1a67c2f6-b8b4-421a-a4f5-d999e2cdd281",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("1ec8b405-0b88-4667-a8db-3b1988a10f2f",
	"1a525e2a-6e59-4d43-bef1-ed2354919d36",
	'te_cs',
	"e95ad139-5ff9-4970-b88f-913d324aa2aa",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("1a525e2a-6e59-4d43-bef1-ed2354919d36",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("ee2ff4b0-aac9-47a2-87de-748addce9389",
	"00000000-0000-0000-0000-000000000000",
	'TE_C_insert',
	'',
	'head_te_c = param.head_te_c;
te_c = param.te_c;
result = te_c;
if ( empty head_te_c )
  // Just starting.  Return te_c as head.
elif ( te_c.Name <= head_te_c.Name )
  // insert before
  relate te_c to head_te_c across R2017.''precedes'';
else
  // find bigger
  result = head_te_c;
  prev_te_c = head_te_c;
  select one cursor_te_c related by head_te_c->TE_C[R2017.''precedes''];
  while ( not_empty cursor_te_c )
    if ( te_c.Name <= cursor_te_c.Name )
      break;
    else
      prev_te_c = cursor_te_c;
      select one cursor_te_c related by cursor_te_c->TE_C[R2017.''precedes''];
    end if;
  end while;
  relate prev_te_c to te_c across R2017.''precedes'';
  if ( not_empty cursor_te_c )
    relate te_c to cursor_te_c across R2017.''precedes'';
  end if;
end if;
return result;
',
	"1a67c2f6-b8b4-421a-a4f5-d999e2cdd281",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("9aead870-b208-4097-b9fc-52982b0b3597",
	"ee2ff4b0-aac9-47a2-87de-748addce9389",
	'head_te_c',
	"1a67c2f6-b8b4-421a-a4f5-d999e2cdd281",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("6c733593-0323-4a2e-a118-4495d3040365",
	"ee2ff4b0-aac9-47a2-87de-748addce9389",
	'te_c',
	"1a67c2f6-b8b4-421a-a4f5-d999e2cdd281",
	0,
	'',
	"9aead870-b208-4097-b9fc-52982b0b3597",
	'');
INSERT INTO PE_PE
	VALUES ("ee2ff4b0-aac9-47a2-87de-748addce9389",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("a268f992-197f-4264-878d-3ed5b8b1b48d",
	"00000000-0000-0000-0000-000000000000",
	'class_sort',
	'',
	'//
// Sort a list of TE_CLASSes.
te_classs = param.te_classs;
// Declare an empty instance reference.
select any head_te_class related by te_classs->TE_CLASS[R2092.''precedes''] where ( false );
for each te_class in te_classs
  end for;
for each te_class in te_classs
  r = ::class_insert( head_te_class:head_te_class, te_class:te_class );
  head_te_class = r;
end for;
return head_te_class;
',
	"a4c72a7c-2bdb-49fd-8096-759f23d860e2",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("2eee0bd5-752d-4b81-8b7a-72fa82f4c26d",
	"a268f992-197f-4264-878d-3ed5b8b1b48d",
	'te_classs',
	"f76e163a-e9e5-4b43-9fb2-aeeda16e3740",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("a268f992-197f-4264-878d-3ed5b8b1b48d",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("f6fff4fc-3435-4068-83dd-f1d8e31df5ff",
	"00000000-0000-0000-0000-000000000000",
	'class_insert',
	'',
	'head_te_class = param.head_te_class;
te_class = param.te_class;
result = te_class;
if ( empty head_te_class )
  // Just starting.  Return te_class as head.
else
  lkey = T::s(i:te_class.Numb) + te_class.GeneratedName;
  rkey = T::s(i:head_te_class.Numb) + head_te_class.GeneratedName;
  if ( lkey <= rkey )
    // insert before
    relate te_class to head_te_class across R2092.''precedes'';
  else
    // find bigger
    result = head_te_class;
    prev_te_class = head_te_class;
    select one cursor_te_class related by head_te_class->TE_CLASS[R2092.''precedes''];
    while ( not_empty cursor_te_class )
      rkey = T::s(i:cursor_te_class.Numb) + cursor_te_class.GeneratedName;
      if ( lkey <= rkey )
        break;
      else
        prev_te_class = cursor_te_class;
        select one cursor_te_class related by cursor_te_class->TE_CLASS[R2092.''precedes''];
      end if;
    end while;
    relate prev_te_class to te_class across R2092.''precedes'';
    if ( not_empty cursor_te_class )
      relate te_class to cursor_te_class across R2092.''precedes'';
    end if;
  end if;
end if;
return result;
',
	"a4c72a7c-2bdb-49fd-8096-759f23d860e2",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("e00dfe80-983b-46d5-97bd-1153320dce8b",
	"f6fff4fc-3435-4068-83dd-f1d8e31df5ff",
	'head_te_class',
	"a4c72a7c-2bdb-49fd-8096-759f23d860e2",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("7eafe647-18b9-443c-beaa-9c9753826b58",
	"f6fff4fc-3435-4068-83dd-f1d8e31df5ff",
	'te_class',
	"a4c72a7c-2bdb-49fd-8096-759f23d860e2",
	0,
	'',
	"e00dfe80-983b-46d5-97bd-1153320dce8b",
	'');
INSERT INTO PE_PE
	VALUES ("f6fff4fc-3435-4068-83dd-f1d8e31df5ff",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("d5ab855c-d8a6-4c59-acf0-ef8088dee9a8",
	"00000000-0000-0000-0000-000000000000",
	'mact_sort',
	'',
	'//
// Sort a list of TE_MACTs.
te_macts = param.te_macts;
// Declare an empty instance reference.
select any head_te_mact related by te_macts->TE_MACT[R2083.''precedes''] where ( false );
for each te_mact in te_macts
  end for;
for each te_mact in te_macts
  r = ::mact_insert( head_te_mact:head_te_mact, te_mact:te_mact );
  head_te_mact = r;
end for;
counter = 0;
te_mact = head_te_mact;
while ( not_empty te_mact )
  te_mact.Order = counter;
  counter = counter + 1;
  select one te_mact related by te_mact->TE_MACT[R2083.''precedes''];
end while;
return head_te_mact;
',
	"026512d0-8760-4cb8-9267-673322497da6",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("c4d04526-6bff-4ff6-9894-ccc0803525f6",
	"d5ab855c-d8a6-4c59-acf0-ef8088dee9a8",
	'te_macts',
	"2cddf1e0-844d-4c61-bc2c-879ff2f006f3",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("2cddf1e0-844d-4c61-bc2c-879ff2f006f3",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref_set<Extended Message Action>',
	'',
	'',
	'../../ooaofooa/Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("d5ab855c-d8a6-4c59-acf0-ef8088dee9a8",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("0a00e4da-84f8-4d09-81c6-486d21575eac",
	"00000000-0000-0000-0000-000000000000",
	'mact_insert',
	'',
	'head_te_mact = param.head_te_mact;
te_mact = param.te_mact;
result = te_mact;
if ( empty head_te_mact )
  // Just starting.  Return te_mact as head.
else
  lkey = te_mact.Name;
  rkey = head_te_mact.Name;
  if ( lkey <= rkey )
    // insert before
    relate te_mact to head_te_mact across R2083.''precedes'';
  else
    // find bigger
    result = head_te_mact;
    prev_te_mact = head_te_mact;
    select one cursor_te_mact related by head_te_mact->TE_MACT[R2083.''precedes''];
    while ( not_empty cursor_te_mact )
      rkey = cursor_te_mact.Name;
      if ( lkey <= rkey )
        break;
      else
        prev_te_mact = cursor_te_mact;
        select one cursor_te_mact related by cursor_te_mact->TE_MACT[R2083.''precedes''];
      end if;
    end while;
    relate prev_te_mact to te_mact across R2083.''precedes'';
    if ( not_empty cursor_te_mact )
      relate te_mact to cursor_te_mact across R2083.''precedes'';
    end if;
  end if;
end if;
return result;
',
	"026512d0-8760-4cb8-9267-673322497da6",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("db0a9741-f043-4892-b5be-7684ac617298",
	"0a00e4da-84f8-4d09-81c6-486d21575eac",
	'head_te_mact',
	"026512d0-8760-4cb8-9267-673322497da6",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("46f034bd-a64a-4cde-9cb5-e901fc9caa36",
	"0a00e4da-84f8-4d09-81c6-486d21575eac",
	'te_mact',
	"026512d0-8760-4cb8-9267-673322497da6",
	0,
	'',
	"db0a9741-f043-4892-b5be-7684ac617298",
	'');
INSERT INTO PE_PE
	VALUES ("0a00e4da-84f8-4d09-81c6-486d21575eac",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("275d3919-9834-4116-8631-3da4d377d8bc",
	"00000000-0000-0000-0000-000000000000",
	'sync_sort',
	'',
	'//
// Sort a list of TE_SYNCs.
te_syncs = param.te_syncs;
// Declare an empty instance reference.
select any head_te_sync related by te_syncs->TE_SYNC[R2095.''precedes''] where ( false );
for each te_sync in te_syncs
  end for;
for each te_sync in te_syncs
  r = ::sync_insert( head_te_sync:head_te_sync, te_sync:te_sync );
  head_te_sync = r;
end for;
return head_te_sync;
',
	"431d4f13-03e4-4577-9b2b-164216735801",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("17bf9726-2524-4137-89bb-8ce09b0f7128",
	"275d3919-9834-4116-8631-3da4d377d8bc",
	'te_syncs',
	"422f437a-4ca4-42ef-9ff8-6cdeacc2a875",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("422f437a-4ca4-42ef-9ff8-6cdeacc2a875",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref_set<Extended Function>',
	'',
	'',
	'../../ooaofooa/Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("275d3919-9834-4116-8631-3da4d377d8bc",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_DT_PROXY
	VALUES ("431d4f13-03e4-4577-9b2b-164216735801",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Extended Function>',
	'',
	'',
	'../../ooaofooa/Translation Extensions/Translation Extensions.xtuml');
INSERT INTO S_SYNC
	VALUES ("0c73daa6-ad4a-4fd3-9199-6eaa458eb2d8",
	"00000000-0000-0000-0000-000000000000",
	'sync_insert',
	'',
	'head_te_sync = param.head_te_sync;
te_sync = param.te_sync;
result = te_sync;
if ( empty head_te_sync )
  // Just starting.  Return te_sync as head.
else
  lkey = te_sync.Name;
  rkey = head_te_sync.Name;
  if ( lkey <= rkey )
    // insert before
    relate te_sync to head_te_sync across R2095.''precedes'';
  else
    // find bigger
    result = head_te_sync;
    prev_te_sync = head_te_sync;
    select one cursor_te_sync related by head_te_sync->TE_SYNC[R2095.''precedes''];
    while ( not_empty cursor_te_sync )
      rkey = cursor_te_sync.Name;
      if ( lkey <= rkey )
        break;
      else
        prev_te_sync = cursor_te_sync;
        select one cursor_te_sync related by cursor_te_sync->TE_SYNC[R2095.''precedes''];
      end if;
    end while;
    relate prev_te_sync to te_sync across R2095.''precedes'';
    if ( not_empty cursor_te_sync )
      relate te_sync to cursor_te_sync across R2095.''precedes'';
    end if;
  end if;
end if;
return result;
',
	"431d4f13-03e4-4577-9b2b-164216735801",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("30894103-984a-46f9-a8cf-e43d88a60962",
	"0c73daa6-ad4a-4fd3-9199-6eaa458eb2d8",
	'head_te_sync',
	"431d4f13-03e4-4577-9b2b-164216735801",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("8f856657-9ee8-4734-b66d-9d5204b3284c",
	"0c73daa6-ad4a-4fd3-9199-6eaa458eb2d8",
	'te_sync',
	"431d4f13-03e4-4577-9b2b-164216735801",
	0,
	'',
	"30894103-984a-46f9-a8cf-e43d88a60962",
	'');
INSERT INTO PE_PE
	VALUES ("0c73daa6-ad4a-4fd3-9199-6eaa458eb2d8",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("fb7bb8fa-b708-49a6-87fc-a684eb9f8910",
	"00000000-0000-0000-0000-000000000000",
	'ee_sort',
	'',
	'//
// Sort a list of TE_EEs.
te_ees = param.te_ees;
// Declare an empty instance reference.
select any head_te_ee related by te_ees->TE_EE[R2096.''precedes''] where ( false );
for each te_ee in te_ees
  select one next_te_ee related by te_ee->TE_EE[R2096.''precedes''];
  if ( not_empty next_te_ee )
    unrelate te_ee from te_ee across R2096.''precedes'';
  end if;
end for;
for each te_ee in te_ees
  r = ::ee_insert( head_te_ee:head_te_ee, te_ee:te_ee );
  head_te_ee = r;
end for;
return head_te_ee;
',
	"b2d4d12f-d262-45d3-b989-4d5a579921b1",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("af73c83f-d88a-444e-b241-8e242b205beb",
	"fb7bb8fa-b708-49a6-87fc-a684eb9f8910",
	'te_ees',
	"75c7fff6-17bd-417a-98a3-59f9bca1070f",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("75c7fff6-17bd-417a-98a3-59f9bca1070f",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref_set<Extended External Entity>',
	'',
	'',
	'../../ooaofooa/Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("fb7bb8fa-b708-49a6-87fc-a684eb9f8910",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("870a51ef-bde3-42d0-bc02-49745dec091a",
	"00000000-0000-0000-0000-000000000000",
	'ee_insert',
	'',
	'head_te_ee = param.head_te_ee;
te_ee = param.te_ee;
result = te_ee;
if ( empty head_te_ee )
  // Just starting.  Return te_ee as head.
else
  lkey = te_ee.Name;
  rkey = head_te_ee.Name;
  if ( lkey <= rkey )
    // insert before
    relate te_ee to head_te_ee across R2096.''precedes'';
  else
    // find bigger
    result = head_te_ee;
    prev_te_ee = head_te_ee;
    select one cursor_te_ee related by head_te_ee->TE_EE[R2096.''precedes''];
    while ( not_empty cursor_te_ee )
      rkey = cursor_te_ee.Name;
      if ( lkey <= rkey )
        break;
      else
        prev_te_ee = cursor_te_ee;
        select one cursor_te_ee related by cursor_te_ee->TE_EE[R2096.''precedes''];
      end if;
    end while;
    relate prev_te_ee to te_ee across R2096.''precedes'';
    if ( not_empty cursor_te_ee )
      relate te_ee to cursor_te_ee across R2096.''precedes'';
    end if;
  end if;
end if;
return result;
',
	"b2d4d12f-d262-45d3-b989-4d5a579921b1",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("05a9e74e-7025-4923-9cc6-65b8cf15e4f0",
	"870a51ef-bde3-42d0-bc02-49745dec091a",
	'head_te_ee',
	"b2d4d12f-d262-45d3-b989-4d5a579921b1",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("f5d703c8-c3c8-4034-9de2-2fd35f754107",
	"870a51ef-bde3-42d0-bc02-49745dec091a",
	'te_ee',
	"b2d4d12f-d262-45d3-b989-4d5a579921b1",
	0,
	'',
	"05a9e74e-7025-4923-9cc6-65b8cf15e4f0",
	'');
INSERT INTO PE_PE
	VALUES ("870a51ef-bde3-42d0-bc02-49745dec091a",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("ab881fa1-f172-4aed-bec7-83a5c1711fc1",
	"00000000-0000-0000-0000-000000000000",
	'blk_indentwhitespace',
	'',
	'//
// indentation maker
//
indentation = param.indentation;
result = "";
while ( 0 < indentation )
  indentation = indentation - 1;
  result = result + "  ";
end while;
return result;
',
	"ba5eda7a-def5-0000-0000-000000000004",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("0bd36cc7-2bbf-42b4-91b7-f7f0b44d750a",
	"ab881fa1-f172-4aed-bec7-83a5c1711fc1",
	'indentation',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("ab881fa1-f172-4aed-bec7-83a5c1711fc1",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("120fb2b5-a1f8-478a-ac46-47a456da38b7",
	"00000000-0000-0000-0000-000000000000",
	'gen_parameter_list',
	'',
	'//====================================================================
//
// $RCSfile: q.utils.arc,v $
//
//
//====================================================================
//
v_pars = param.v_pars;
prefix_param_delimiter = param.prefix_param_delimiter;
//
code = "";
OAL = "";
select any te_parm from instances of TE_PARM;
if ( not_empty v_pars )
  select any te_string from instances of TE_STRING;
  item_count = 0;
  lowest_order = 999;
  select many te_pars related by v_pars->TE_PAR[R2063];
  for each te_par in te_pars
    select one te_parm related by te_par->TE_PARM[R2091];
    te_par.Order = te_parm.Order;
    if ( te_par.Order < lowest_order )
      lowest_order = te_par.Order;
    end if;
    item_count = item_count + 1;
  end for;
  item_number = lowest_order;
  param_delimiter = "";
  if ( prefix_param_delimiter )
    param_delimiter = ",";
  end if;
  while ( item_number < ( item_count + lowest_order ) )
    select any te_par related by v_pars->TE_PAR[R2063] where ( selected.Order == item_number );
    select one v_par related by te_par->V_PAR[R2063];
    select one v_val related by v_par->V_VAL[R800];
    select one te_val related by v_val->TE_VAL[R2040];
    OAL = ( OAL + param_delimiter ) + te_val.OAL;
    if ( "" == te_val.buffer )
      ::gen_value( v_val:v_val );
    end if;
    code = code + param_delimiter;
    //
    if ( 0 == te_par.By_Ref )
      code = code + te_val.buffer;
    else
      code = ( ( code + "&(" ) + ( te_val.buffer + ")" ) );
    end if;
    param_delimiter = ", ";
    item_number = item_number + 1;
  end while;
end if;
te_parm.ParamBuffer = code;
te_parm.OALParamBuffer = OAL;
return te_parm;
',
	"7a7c55de-19e8-42d0-81a9-1d26e33982ad",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("27b9387c-7cef-4ac6-9f0d-6cccd5d6bf63",
	"120fb2b5-a1f8-478a-ac46-47a456da38b7",
	'v_pars',
	"cff0610c-aa78-4735-bf53-f7fa31ce74fd",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("cff0610c-aa78-4735-bf53-f7fa31ce74fd",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref_set<Actual Parameter>',
	'',
	'',
	'../../ooaofooa/Value/Value.xtuml');
INSERT INTO S_SPARM
	VALUES ("b789a6e1-fe41-4752-ac7d-159b93823d86",
	"120fb2b5-a1f8-478a-ac46-47a456da38b7",
	'prefix_param_delimiter',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'',
	"27b9387c-7cef-4ac6-9f0d-6cccd5d6bf63",
	'');
INSERT INTO PE_PE
	VALUES ("120fb2b5-a1f8-478a-ac46-47a456da38b7",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("c07fff98-7bfc-430e-be35-49ee1ad7a563",
	"00000000-0000-0000-0000-000000000000",
	'is_reflexive',
	'',
	'//
//====================================================================
//
r_rel = param.r_rel;
//
result = false;
select one r_simp related by r_rel->R_SIMP[R206];
if ( not_empty r_simp )
  select many r_parts related by r_simp->R_PART[R207];
  if ( ( cardinality r_parts ) > 1 )
    select any first_r_part related by r_simp->R_PART[R207];
    select any second_r_part related by r_simp->R_PART[R207] where ( selected.OIR_ID != first_r_part.OIR_ID );
    if ( first_r_part.Obj_ID == second_r_part.Obj_ID )
      result = true;
    end if;
  else
    select any r_part related by r_simp->R_PART[R207];
    select one r_form related by r_simp->R_FORM[R208];
    if ( not_empty r_form )
      if ( r_part.Obj_ID == r_form.Obj_ID )
        result = true;
      end if;
    end if;
  end if;
else
  select one r_assoc related by r_rel->R_ASSOC[R206];
  if ( not_empty r_assoc )
    select one r_aone related by r_assoc->R_AONE[R209];
    select one r_aoth related by r_assoc->R_AOTH[R210];
    if ( r_aone.Obj_ID == r_aoth.Obj_ID )
      result = true;
    end if;
  end if;
end if;
return result;
',
	"ba5eda7a-def5-0000-0000-000000000001",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("4dba17a4-501f-4710-be7f-52fb81a2f072",
	"c07fff98-7bfc-430e-be35-49ee1ad7a563",
	'r_rel',
	"4480b008-8c74-4f57-9256-08b7365520bc",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("4480b008-8c74-4f57-9256-08b7365520bc",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Association>',
	'',
	'',
	'../../ooaofooa/Association/Association.xtuml');
INSERT INTO PE_PE
	VALUES ("c07fff98-7bfc-430e-be35-49ee1ad7a563",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("b2c610b2-379e-4b95-b4fe-3c43aae2ecde",
	"00000000-0000-0000-0000-000000000000",
	't_oal_smt_event_parameters',
	'',
	'//------------------------------------------------
// Note the use of p_ here.  It is hard-coded and depends upon
// matching the prefix used in initialization population query.
evt_msg_var = param.evt_msg_var;
parameter = param.parameter;
value = param.value;
value_type = param.value_type;
ws = param.ws;
result = "";
select any te_eq from instances of TE_EQ;
if ( "" == evt_msg_var )
  evt_msg_var = te_eq.event_message_variable;
end if;
if ( 4 == value_type )
  // string
  select any te_string from instances of TE_STRING;
  select any te_instance from instances of TE_INSTANCE;
  result = "${ws}  ${te_instance.module}${te_string.strcpy}( ${evt_msg_var}->p_${parameter}, ${value} );";
else
  result = "${ws}  ${evt_msg_var}->p_${parameter} = ${value};";
end if;
return result;
',
	"ba5eda7a-def5-0000-0000-000000000004",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("d1b1d45b-72e6-4fe8-a8fe-9336de3588ca",
	"b2c610b2-379e-4b95-b4fe-3c43aae2ecde",
	'evt_msg_var',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("57804ffb-c08f-4225-8c5f-0fb99e78da38",
	"b2c610b2-379e-4b95-b4fe-3c43aae2ecde",
	'parameter',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"d1b1d45b-72e6-4fe8-a8fe-9336de3588ca",
	'');
INSERT INTO S_SPARM
	VALUES ("01ca746b-2b0c-4401-9373-e7e554a4caf4",
	"b2c610b2-379e-4b95-b4fe-3c43aae2ecde",
	'value',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"57804ffb-c08f-4225-8c5f-0fb99e78da38",
	'');
INSERT INTO S_SPARM
	VALUES ("d1e46b27-89c7-4f42-a53a-479ce5bd8048",
	"b2c610b2-379e-4b95-b4fe-3c43aae2ecde",
	'value_type',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"01ca746b-2b0c-4401-9373-e7e554a4caf4",
	'');
INSERT INTO S_SPARM
	VALUES ("99072f73-86b6-4f9f-9444-f10803c523f9",
	"b2c610b2-379e-4b95-b4fe-3c43aae2ecde",
	'ws',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"d1e46b27-89c7-4f42-a53a-479ce5bd8048",
	'');
INSERT INTO PE_PE
	VALUES ("b2c610b2-379e-4b95-b4fe-3c43aae2ecde",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("08aec77c-3f05-469e-ad03-6269007844c3",
	"00000000-0000-0000-0000-000000000000",
	'container_factory',
	'',
	'//
te_container = param.te_container;
te_container.flavor = "";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("e3bc4afc-095a-45eb-aff0-f378b5df0404",
	"08aec77c-3f05-469e-ad03-6269007844c3",
	'te_container',
	"c0e44014-c8a7-43c6-a2f3-0fc646cc1ad2",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("c0e44014-c8a7-43c6-a2f3-0fc646cc1ad2",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<container>',
	'',
	'',
	'../../ooaofooa/Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("08aec77c-3f05-469e-ad03-6269007844c3",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("c4858c58-40b2-4bfc-85f2-e85f6d9a6235",
	"00000000-0000-0000-0000-000000000000",
	'copyright_factory',
	'',
	'//
//
te_copyright = param.te_copyright;
te_copyright.body = "your copyright statement can go here (from te_copyright.body)";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("93206bd6-59c9-4ed4-8925-319314a6b7fc",
	"c4858c58-40b2-4bfc-85f2-e85f6d9a6235",
	'te_copyright',
	"0f110072-3d76-4383-b41a-f718a1bc505d",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("0f110072-3d76-4383-b41a-f718a1bc505d",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<copyright>',
	'',
	'',
	'../../ooaofooa/Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("c4858c58-40b2-4bfc-85f2-e85f6d9a6235",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("b1aa8f24-2e74-4c6e-8dda-ba07a22c3b37",
	"00000000-0000-0000-0000-000000000000",
	'dlist_factory',
	'',
	'//
//
te_dlist = param.te_dlist;
select any te_prefix from instances of TE_PREFIX;
te_dlist.remove_node = te_prefix.result + "SetRemoveDlistNode";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("3ea10bf9-5fd5-4c64-8475-729495ace58b",
	"b1aa8f24-2e74-4c6e-8dda-ba07a22c3b37",
	'te_dlist',
	"d6733a38-5b27-4a85-a132-227bcad2de8b",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("d6733a38-5b27-4a85-a132-227bcad2de8b",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<dlist>',
	'',
	'',
	'../../ooaofooa/Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("b1aa8f24-2e74-4c6e-8dda-ba07a22c3b37",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("e20e0f8e-3dd4-4d6b-9705-cfcec66a3cf2",
	"00000000-0000-0000-0000-000000000000",
	'dma_factory',
	'',
	'//
//
te_dma = param.te_dma;
select any te_prefix from instances of TE_PREFIX;
te_dma.file = "sys_memory";
te_dma.allocate = te_prefix.result + "malloc";
te_dma.release = te_prefix.result + "free";
te_dma.debugging_heap = false;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("26307b28-ca1a-4672-80a6-e75392d048fe",
	"e20e0f8e-3dd4-4d6b-9705-cfcec66a3cf2",
	'te_dma',
	"4954e1b6-37ae-4dc4-8de9-e6ad79dc5b34",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("4954e1b6-37ae-4dc4-8de9-e6ad79dc5b34",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<dynamic memory allocation>',
	'',
	'',
	'../../ooaofooa/Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("e20e0f8e-3dd4-4d6b-9705-cfcec66a3cf2",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("d501340d-9aff-497b-b1cf-10f48b04af50",
	"00000000-0000-0000-0000-000000000000",
	'eq_factory',
	'',
	'//
//
te_eq = param.te_eq;
select any te_prefix from instances of TE_PREFIX;
te_eq.ignored = "EVENT_IS_IGNORED";
te_eq.cant_happen = "EVENT_CANT_HAPPEN";
te_eq.system_events_union = te_prefix.result + "systemxtUMLevents";
te_eq.system_event_pool = te_prefix.result + "xtUML_event_pool";
te_eq.constant_type = te_prefix.result + "xtUMLEventConstant_t";
te_eq.base_event_type = te_prefix.result + "xtUMLEvent_t";
te_eq.base_variable = "mc_event_base";
te_eq.max_events = te_prefix.define_u + "SYS_MAX_XTUML_EVENTS";
te_eq.max_self_events = te_prefix.define_u + "SYS_MAX_SELF_EVENTS";
te_eq.max_nonself_events = te_prefix.define_u + "SYS_MAX_NONSELF_EVENTS";
te_eq.new = te_prefix.result + "NewxtUMLEvent";
te_eq.allocate = te_prefix.result + "AllocatextUMLEvent";
te_eq.delete = te_prefix.result + "DeletextUMLEvent";
te_eq.modify = te_prefix.result + "ModifyxtUMLEvent";
te_eq.self = te_prefix.result + "SendSelfEvent";
te_eq.non_self = te_prefix.result + "SendEvent";
te_eq.search_and_destroy = te_prefix.result + "EventSearchAndDestroy";
te_eq.run_flag = te_prefix.result + "run_flag";
te_eq.event_message_variable = "e";
te_eq.scope = "";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("11a35362-f464-409c-b5f6-7c2563747860",
	"d501340d-9aff-497b-b1cf-10f48b04af50",
	'te_eq',
	"3115cecb-d2fa-45d7-aeac-f6559c8e3393",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("3115cecb-d2fa-45d7-aeac-f6559c8e3393",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<event queue>',
	'',
	'',
	'../../ooaofooa/Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("d501340d-9aff-497b-b1cf-10f48b04af50",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("bd8c722d-f135-4236-b809-13f61ae4524d",
	"00000000-0000-0000-0000-000000000000",
	'extent_factory',
	'',
	'//
//
te_extent = param.te_extent;
select any te_prefix from instances of TE_PREFIX;
select any te_set from instances of TE_SET;
select any te_typemap from instances of TE_TYPEMAP;
select any te_instance from instances of TE_INSTANCE;
te_extent.sets_type = te_set.base_class;
te_extent.type = te_prefix.result + "Extent_t";
te_extent.active = "active";
te_extent.inactive = "inactive";
te_extent.size_type = te_typemap.object_size_name;
te_extent.istate_type = te_typemap.state_number_name;
te_extent.istate_name = "initial_state";
te_extent.container_type = te_set.element_type + "*";
te_extent.container_name = "container";
te_extent.pool_type = te_instance.handle;
te_extent.pool_name = "pool";
te_extent.population_type = te_typemap.instance_index_name;
te_extent.population_name = "population";
te_extent.rstorsize_type = te_typemap.object_size_name;
te_extent.rstorsize_name = "size_no_rel";
te_extent.linkfunc_name = "link_function";
te_extent.size_name = "size";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("fd39d5ef-0ace-412c-8afb-80fec024a86b",
	"bd8c722d-f135-4236-b809-13f61ae4524d",
	'te_extent',
	"516530a6-7571-45b3-af9c-e01411a5151b",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("516530a6-7571-45b3-af9c-e01411a5151b",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<extent>',
	'',
	'',
	'../../ooaofooa/Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("bd8c722d-f135-4236-b809-13f61ae4524d",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("b075a02e-d32b-4e4c-a619-171e2ad7f480",
	"00000000-0000-0000-0000-000000000000",
	'file_factory',
	'',
	'//
//
te_file = param.te_file;
select any te_prefix from instances of TE_PREFIX;
te_file.hdr_file_ext = "h";
te_file.src_file_ext = "c";
te_file.sys_main = te_prefix.file + "sys_main";
te_file.factory = te_prefix.file + "sys_xtuml";
te_file.events = te_prefix.file + "sys_events";
te_file.obj_file_ext = "o";
te_file.nvs = te_prefix.file + "sys_nvs";
te_file.sets = te_prefix.file + "sys_sets";
te_file.types = te_prefix.file + "sys_types";
te_file.thread = te_prefix.file + "sys_thread";
te_file.trace = te_prefix.file + "sys_trace";
te_file.tim = te_prefix.file + "TIM_bridge";
te_file.callout = te_prefix.file + "sys_user_co";
te_file.ilb = te_prefix.file + "sys_ilb";
te_file.persist = te_prefix.file + "sys_persist";
te_file.xtumlload = te_prefix.file + "sys_xtumlload";
te_file.interfaces = te_prefix.file + "sysc_interfaces";
te_file.registers = te_prefix.file + "RegDefs";
te_file.domain_color_path = ".";
te_file.domain_source_path = "_ch";
te_file.domain_include_path = "_ch";
te_file.system_source_path = "_ch";
te_file.system_include_path = "_ch";
te_file.system_color_path = ".";
te_file.system_mark = "system.mark";
te_file.datatype_mark = "datatype.mark";
te_file.event_mark = "event.mark";
te_file.class_mark = "class.mark";
te_file.domain_mark = "domain.mark";
te_file.system_functions_mark = "sys_functions.arc";
te_file.bridge_mark = "bridge.mark";
te_file.nvs_bridge = te_prefix.file + "NVS_bridge";
te_file.arc_path = "mc3020/arc";
te_file.root_path = ".";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("345fe2f3-d6c6-42a4-962b-bec5d719fb57",
	"b075a02e-d32b-4e4c-a619-171e2ad7f480",
	'te_file',
	"ca7699b5-df14-4eb3-94c2-012654a3804a",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("ca7699b5-df14-4eb3-94c2-012654a3804a",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<file>',
	'',
	'',
	'../../ooaofooa/Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("b075a02e-d32b-4e4c-a619-171e2ad7f480",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("7adb567a-d712-40a7-b057-ee389a23bc1b",
	"00000000-0000-0000-0000-000000000000",
	'instance_factory',
	'',
	'//
//
te_instance = param.te_instance;
select any te_prefix from instances of TE_PREFIX;
te_instance.scope = "";
te_instance.create = te_prefix.result + "CreateInstance";
te_instance.create_persistent = te_prefix.result + "CreatePersistent";
te_instance.delete = te_prefix.result + "DeleteInstance";
te_instance.delete_persistent = te_prefix.result + "DeletePersistent";
te_instance.self = "self";
te_instance.global_self = te_prefix.result + "GetSelf";
te_instance.base = te_prefix.result + "InstanceBase_t";
te_instance.handle = te_prefix.result + "iHandle_t";
te_instance.factory_init = te_prefix.result + "ClassFactoryInit";
te_instance.get_dci = te_prefix.result + "GetDCI";
te_instance.get_event_dispatcher = te_prefix.result + "GetEventDispatcher";
te_instance.get_thread_assignment = te_prefix.result + "GetThreadAssignment";
te_instance.base_class = te_prefix.result + "Object_s";
te_instance.max_extent = te_prefix.define_u + "SYS_MAX_OBJECT_EXTENT";
te_instance.max_association_extent = te_prefix.define_u + "SYS_MAX_ASSOCIATION_EXTENT";
te_instance.max_transient_extent = te_prefix.define_u + "SYS_MAX_TRANSIENT_EXTENT";
te_instance.current_state = "current_state";
te_instance.module = "";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("ce9a2343-cc0a-47e6-b10e-d1f135b3702c",
	"7adb567a-d712-40a7-b057-ee389a23bc1b",
	'te_instance',
	"de4b7b15-2e0b-4599-a8c8-84984bbfef73",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("de4b7b15-2e0b-4599-a8c8-84984bbfef73",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<instance>',
	'',
	'',
	'../../ooaofooa/Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("7adb567a-d712-40a7-b057-ee389a23bc1b",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("9d8ba0c5-a8fa-45b9-9316-c6f23bf222da",
	"00000000-0000-0000-0000-000000000000",
	'ilb_factory',
	'',
	'//
//
te_ilb = param.te_ilb;
select any te_prefix from instances of TE_PREFIX;
te_ilb.file = "sys_ilb";
te_ilb.interleave_bridge = "InterleaveBridge";
te_ilb.define_name = te_prefix.define_u + "SYS_MAX_INTERLEAVED_BRIDGES";
te_ilb.data_define_name = te_prefix.define_u + "SYS_MAX_INTERLEAVED_BRIDGE_DATA";
te_ilb.interleave_bridge_done = "InterleaveBridgeDone";
te_ilb.get_data = "GetILBData";
te_ilb.dispatch = "DispatchInterleaveBridge";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("5d90b1e3-dc22-4450-87b1-067a09932b10",
	"9d8ba0c5-a8fa-45b9-9316-c6f23bf222da",
	'te_ilb',
	"202ecd97-a6b9-4753-a14d-6289c9bfd0ca",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("202ecd97-a6b9-4753-a14d-6289c9bfd0ca",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<interleaved bridge>',
	'',
	'',
	'../../ooaofooa/Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("9d8ba0c5-a8fa-45b9-9316-c6f23bf222da",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("e1f38dd1-9fa8-4520-b24b-580c987ceebd",
	"00000000-0000-0000-0000-000000000000",
	'persist_factory',
	'',
	'//
//
te_persist = param.te_persist;
select any te_prefix from instances of TE_PREFIX;
select any te_typemap from instances of TE_TYPEMAP;
te_persist.class_union = "";
te_persist.instance_cache_depth = te_prefix.define_u + "PERSIST_INST_CACHE_DEPTH";
te_persist.check_mark = "check_mark_post";
te_persist.post_link = "";
te_persist.link_type_name = te_prefix.type + "link_t";
te_persist.persist_file = "sys_persist";
te_persist.factory_init = te_prefix.result + "PersistFactoryInit";
te_persist.commit = te_prefix.result + "PersistenceCommit";
te_persist.restore = te_prefix.result + "PersistenceRestore";
te_persist.remove = te_prefix.result + "PersistDelete";
te_persist.link_cache_depth = te_prefix.define_u + "PERSIST_LINK_CACHE_DEPTH";
// Return the name of the extended attribute variable for use by
// the persistent restore operation.  This attribute represents the
// instance index of the class extent at time of persistent stowage
// together with the class number (across domains) of the class.
// Also return the types for this attribute variable.
te_persist.domainnum_name = "domainnum";
te_persist.domainnum_type = te_typemap.domain_number_name;
te_persist.classnum_name = "classnum";
te_persist.classnum_type = te_typemap.object_number_name;
te_persist.index_name = "index";
te_persist.index_type = te_typemap.instance_index_name;
te_persist.instid_type = "InstanceIdentifier_t";
te_persist.instid_name = "instance_identifier";
te_persist.dirty_type = "s1_t";
te_persist.dirty_name = "persist_dirty";
te_persist.dirty_dirty = 1;
te_persist.dirty_clean = 0;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("9524c4e8-32c7-46f0-8287-ac650973f4ea",
	"e1f38dd1-9fa8-4520-b24b-580c987ceebd",
	'te_persist',
	"5990799b-8703-4533-848d-90abdf8df5ba",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("5990799b-8703-4533-848d-90abdf8df5ba",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<persistence>',
	'',
	'',
	'../../ooaofooa/Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("e1f38dd1-9fa8-4520-b24b-580c987ceebd",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("9b7f90cd-94f8-456c-bb84-ac537b2ae5a8",
	"00000000-0000-0000-0000-000000000000",
	'prefix_factory',
	'',
	'//
//
te_prefix = param.te_prefix;
te_prefix.symbol = "Escher_";
te_prefix.type = "Escher_";
te_prefix.define_u = "ESCHER_";
te_prefix.define_c = "Escher_";
te_prefix.symbolsw = "";
te_prefix.typesw = "";
te_prefix.result = "Escher_";
te_prefix.define_csw = "";
te_prefix.define_usw = "";
te_prefix.file = "";
te_prefix.provided_port = "pport_";
te_prefix.required_port = "rport_";
te_prefix.channel = "channel_";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("51b7afec-5cba-4041-a14d-5cdc5d2fe304",
	"9b7f90cd-94f8-456c-bb84-ac537b2ae5a8",
	'te_prefix',
	"7cfb8b97-95b3-42bf-80d6-6a750f6e0bfd",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("7cfb8b97-95b3-42bf-80d6-6a750f6e0bfd",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<prefix>',
	'',
	'',
	'../../ooaofooa/Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("9b7f90cd-94f8-456c-bb84-ac537b2ae5a8",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("9d468067-5c4c-455a-9a7f-bb66ee7837b1",
	"00000000-0000-0000-0000-000000000000",
	'relinfo_factory',
	'',
	'//
//
te_relinfo = param.te_relinfo;
te_relinfo.multiplicity = 0;
te_relinfo.rel_phrase = "";
te_relinfo.is_formalizer = false;
te_relinfo.is_supertype = false;
te_relinfo.generate_subtype = false;
te_relinfo.gen_declaration = false;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("12d9832a-6077-4530-a24a-d7ca8d957c0f",
	"9d468067-5c4c-455a-9a7f-bb66ee7837b1",
	'te_relinfo',
	"c737ff7f-2b3a-46c8-aea3-48c6dc6a449d",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("c737ff7f-2b3a-46c8-aea3-48c6dc6a449d",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<relationship information>',
	'',
	'',
	'../../ooaofooa/Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("9d468067-5c4c-455a-9a7f-bb66ee7837b1",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("7d483e12-cb7d-4814-a672-154df6c0bb92",
	"00000000-0000-0000-0000-000000000000",
	'relstore_factory',
	'',
	'//
//
te_relstore = param.te_relstore;
te_relstore.data_init = "";
te_relstore.link_calls = "";
te_relstore.link_index = 0;
te_relstore.data_fini = "";
te_relstore.self_name = "self";
te_relstore.data_declare = "";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("aa34c84d-6719-4673-bda3-7a24dec01e1c",
	"7d483e12-cb7d-4814-a672-154df6c0bb92",
	'te_relstore',
	"60fd9c8e-e6ac-4c8a-ae6d-65aa2fa3166a",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("60fd9c8e-e6ac-4c8a-ae6d-65aa2fa3166a",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<relationship storage>',
	'',
	'',
	'../../ooaofooa/Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("7d483e12-cb7d-4814-a672-154df6c0bb92",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("b5c84e16-1705-4a17-81d0-076b772d8ec1",
	"00000000-0000-0000-0000-000000000000",
	'set_factory',
	'',
	'//
//
te_set = param.te_set;
select any te_prefix from instances of TE_PREFIX;
te_set.module = "";
te_set.copy = te_prefix.result + "CopySet";
te_set.clear = te_prefix.result + "ClearSet";
te_set.insert_element = te_prefix.result + "SetInsertElement";
te_set.element_count = te_prefix.result + "SetCardinality";
te_set.iterator_class_name = te_prefix.result + "Iterator_s";
te_set.number_of_containoids = te_prefix.define_usw + "SYS_MAX_CONTAINERS";
te_set.factory = te_prefix.result + "SetFactoryInit";
te_set.insert_block = te_prefix.result + "SetInsertBlock";
te_set.remove_instance = te_prefix.result + "SetRemoveInstance";
te_set.contains = te_prefix.result + "SetContains";
te_set.equality = te_prefix.result + "SetEquality";
te_set.init = te_prefix.result + "InitSet";
te_set.insert_instance = te_prefix.result + "SetInsertInstance";
te_set.emptiness = te_prefix.result + "SetIsEmpty";
te_set.get_any = te_prefix.result + "SetGetAny";
te_set.remove_element = te_prefix.result + "SetRemoveElement";
te_set.iterator_reset = te_prefix.result + "IteratorReset";
te_set.iterator_next = te_prefix.result + "IteratorNext";
te_set.base_class = te_prefix.result + "ObjectSet_s";
te_set.element_type = te_prefix.result + "SetElement_s";
te_set.scope = "";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("da60452e-3895-4db7-b5fa-52d2608509ef",
	"b5c84e16-1705-4a17-81d0-076b772d8ec1",
	'te_set',
	"e7f51310-65ec-4540-987b-28bd08436f67",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("e7f51310-65ec-4540-987b-28bd08436f67",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<set>',
	'',
	'',
	'../../ooaofooa/Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("b5c84e16-1705-4a17-81d0-076b772d8ec1",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("09207b22-da55-4dfe-a7c1-7c3aff64aadb",
	"00000000-0000-0000-0000-000000000000",
	'slist_factory',
	'',
	'//
//
te_slist = param.te_slist;
select any te_prefix from instances of TE_PREFIX;
te_slist.remove_node = te_prefix.result + "SetRemoveNode";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("523f5b11-ae9e-4a20-b691-2df5a20a2e23",
	"09207b22-da55-4dfe-a7c1-7c3aff64aadb",
	'te_slist',
	"8e304392-ee5f-498c-a184-298022c7907f",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("8e304392-ee5f-498c-a184-298022c7907f",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<slist>',
	'',
	'',
	'../../ooaofooa/Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("09207b22-da55-4dfe-a7c1-7c3aff64aadb",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("e9a47cae-043f-4187-a789-58b36a42a513",
	"00000000-0000-0000-0000-000000000000",
	'string_factory',
	'',
	'//
//
te_string = param.te_string;
select any te_prefix from instances of TE_PREFIX;
te_string.memset = te_prefix.result + "memset";
te_string.memmove = te_prefix.result + "memmove";
te_string.strcpy = te_prefix.result + "strcpy";
te_string.stradd = te_prefix.result + "stradd";
te_string.strlen = te_prefix.result + "strlen";
te_string.itoa = te_prefix.result + "itoa";
te_string.atoi = te_prefix.result + "atoi";
te_string.strcmp = te_prefix.result + "strcmp";
te_string.strget = te_prefix.result + "strget";
te_string.max_string_length = te_prefix.define_u + "SYS_MAX_STRING_LEN";
te_string.debug_buffer_depth = te_prefix.define_u + "DEBUG_BUFFER_DEPTH";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("c1dad180-df74-4081-885d-4d65ae5752eb",
	"e9a47cae-043f-4187-a789-58b36a42a513",
	'te_string',
	"95324c98-2506-45ec-a1b4-fd4c3dcf8dbb",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("95324c98-2506-45ec-a1b4-fd4c3dcf8dbb",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<string>',
	'',
	'',
	'../../ooaofooa/Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("e9a47cae-043f-4187-a789-58b36a42a513",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("f8ca2183-77c7-4e6e-9498-0d55ad6e2902",
	"00000000-0000-0000-0000-000000000000",
	'thread_factory',
	'',
	'//
//
te_thread = param.te_thread;
select any te_prefix from instances of TE_PREFIX;
te_thread.file = "sys_thread";
te_thread.mutex_lock = te_prefix.result + "mutex_lock";
te_thread.mutex_unlock = te_prefix.result + "mutex_unlock";
te_thread.nonbusy_wait = te_prefix.result + "nonbusy_wait";
te_thread.nonbusy_wake = te_prefix.result + "nonbusy_wake";
te_thread.shutdown = te_prefix.result + "thread_shutdown";
te_thread.create = te_prefix.result + "thread_create";
te_thread.enabled = false;
te_thread.flavor = "POSIX";
te_thread.serialize = false;
te_thread.number_of_threads = 1;
te_thread.extra_initialization = "";
te_thread.AUTOSAR_enabled = te_prefix.define_usw + "AUTOSAR_ENABLED";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("0cd9ae9e-0454-49b5-8ce9-b27d3c2b9238",
	"f8ca2183-77c7-4e6e-9498-0d55ad6e2902",
	'te_thread',
	"35a81922-4700-49ad-9a7c-0c4c28565fe0",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("35a81922-4700-49ad-9a7c-0c4c28565fe0",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<thread>',
	'',
	'',
	'../../ooaofooa/Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("f8ca2183-77c7-4e6e-9498-0d55ad6e2902",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("85ecde4a-18bb-4089-b71e-5a4d87d14d9e",
	"00000000-0000-0000-0000-000000000000",
	'tim_factory',
	'',
	'//
//
te_tim = param.te_tim;
select any te_prefix from instances of TE_PREFIX;
te_tim.max_timers = te_prefix.define_u + "SYS_MAX_XTUML_TIMERS";
te_tim.keyed_timer_support = false;
te_tim.recurring_timer_support = true;
te_tim.internal_type = "ETimer_t";
te_tim.timer_event_search_and_destroy = false;
te_tim.event_name = "";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("3f3bfa6e-8503-4d39-b3a1-1be843777a0b",
	"85ecde4a-18bb-4089-b71e-5a4d87d14d9e",
	'te_tim',
	"63d8c028-de06-497a-ab26-a7b9d13d597a",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("63d8c028-de06-497a-ab26-a7b9d13d597a",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<timer>',
	'',
	'',
	'../../ooaofooa/Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("85ecde4a-18bb-4089-b71e-5a4d87d14d9e",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("8d31d9ce-7549-4aa9-ac5e-2586ff63feb4",
	"00000000-0000-0000-0000-000000000000",
	'typemap_factory',
	'',
	'//
//
te_typemap = param.te_typemap;
select any te_prefix from instances of TE_PREFIX;
te_typemap.instance_index_name = te_prefix.result + "InstanceIndex_t";
te_typemap.instance_index_type = "u2_t";
te_typemap.object_size_name = te_prefix.type + "ClassSize_t";
te_typemap.object_size_type = te_prefix.type + "size_t";
te_typemap.object_number_name = te_prefix.type + "ClassNumber_t";
te_typemap.object_number_type = "u2_t";
te_typemap.state_number_name = te_prefix.type + "StateNumber_t";
te_typemap.state_number_type = "u1_t";
te_typemap.domain_number_name = te_prefix.type + "DomainNumber_t";
te_typemap.domain_number_type = "u1_t";
te_typemap.event_number_name = te_prefix.type + "EventNumber_t";
te_typemap.event_number_type = "u1_t";
te_typemap.event_priority_name = te_prefix.type + "EventPriority_t";
te_typemap.event_priority_type = "u1_t";
te_typemap.event_flags_name = te_prefix.type + "EventFlags_t";
te_typemap.event_flags_type = "u1_t";
te_typemap.poly_return_name = te_prefix.type + "PolyEventRC_t";
te_typemap.poly_return_type = "u1_t";
te_typemap.SEM_cell_type = "u1_t";
te_typemap.SEM_cell_name = te_prefix.type + "SEMcell_t";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("0ea1d54b-893f-48c8-9970-92abe0070d59",
	"8d31d9ce-7549-4aa9-ac5e-2586ff63feb4",
	'te_typemap',
	"f008920f-6cdd-4a52-8391-9b3ae344af15",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("f008920f-6cdd-4a52-8391-9b3ae344af15",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<type map>',
	'',
	'',
	'../../ooaofooa/Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("8d31d9ce-7549-4aa9-ac5e-2586ff63feb4",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("c5f4cfec-99de-4a8c-b7a9-7b853420dfee",
	"00000000-0000-0000-0000-000000000000",
	'callout_factory',
	'',
	'//
//
te_callout = param.te_callout;
select any te_prefix from instances of TE_PREFIX;
te_callout.initialization = te_prefix.symbolsw + "UserInitializationCallout";
te_callout.pre_xtUML_initialization = te_prefix.symbolsw + "UserPreOoaInitializationCallout";
te_callout.post_xtUML_initialization = te_prefix.symbolsw + "UserPostOoaInitializationCallout";
te_callout.background_processing = te_prefix.symbolsw + "UserBackgroundProcessingCallout";
te_callout.pre_shutdown = te_prefix.symbolsw + "UserPreShutdownCallout";
te_callout.event_no_instance = te_prefix.symbolsw + "UserEventNoInstanceCallout";
te_callout.event_free_list_empty = te_prefix.symbolsw + "UserEventFreeListEmptyCallout";
te_callout.object_pool_empty = te_prefix.symbolsw + "UserObjectPoolEmptyCallout";
te_callout.node_list_empty = te_prefix.symbolsw + "UserNodeListEmptyCallout";
te_callout.interleaved_bridge_overflow = te_prefix.symbolsw + "UserInterleavedBridgeOverflowCallout";
te_callout.self_event_queue_empty = te_prefix.symbolsw + "UserSelfEventQueueEmptyCallout";
te_callout.non_self_event_queue_empty = te_prefix.symbolsw + "UserNonSelfEventQueueEmptyCallout";
te_callout.persistence_error = te_prefix.symbolsw + "UserPersistenceErrorCallout";
te_callout.file = "sys_user_co";
te_callout.post_shutdown = te_prefix.symbolsw + "UserPostShutdownCallout";
te_callout.event_cant_happen = te_prefix.symbolsw + "UserEventCantHappenCallout";
te_callout.empty_handle_detected = te_prefix.symbolsw + "UserEmptyHandleDetectedCallout";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("bcd6d223-3f4e-4d60-85ba-256a44bf6028",
	"c5f4cfec-99de-4a8c-b7a9-7b853420dfee",
	'te_callout',
	"8b12b37d-a579-4e36-b42c-4511700e39a0",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("8b12b37d-a579-4e36-b42c-4511700e39a0",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<user callout>',
	'',
	'',
	'../../ooaofooa/Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("c5f4cfec-99de-4a8c-b7a9-7b853420dfee",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("1a4e4ad3-8d0a-49ea-bd24-42a99a791a26",
	"00000000-0000-0000-0000-000000000000",
	'trace_factory',
	'',
	'//
//
te_trace = param.te_trace;
select any te_prefix from instances of TE_PREFIX;
te_trace.component_msg_start = te_prefix.define_usw + "COMP_MSG_START_TRACE";
te_trace.component_msg_end = te_prefix.define_usw + "COMP_MSG_END_TRACE";
te_trace.state_txn_start = te_prefix.define_usw + "STATE_TXN_START_TRACE";
te_trace.oal_trace = te_prefix.define_usw + "OAL_ACTION_TRACE";
te_trace.state_txn_end = te_prefix.define_usw + "STATE_TXN_END_TRACE";
te_trace.state_txn_event_ignored = te_prefix.define_usw + "STATE_TXN_IG_TRACE";
te_trace.state_txn_cant_happen = te_prefix.define_usw + "STATE_TXN_CH_TRACE";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("a39b072c-ab2e-4734-97a6-d0c1fe340e9a",
	"1a4e4ad3-8d0a-49ea-bd24-42a99a791a26",
	'te_trace',
	"6d2ab5ff-8b45-4cc3-940b-790cfde85eef",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("6d2ab5ff-8b45-4cc3-940b-790cfde85eef",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<trace>',
	'',
	'',
	'../../ooaofooa/Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("1a4e4ad3-8d0a-49ea-bd24-42a99a791a26",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("e99993d4-5add-4567-8eac-dc1566a17bf6",
	"00000000-0000-0000-0000-000000000000",
	'target_factory',
	'',
	'//
te_target = param.te_target;
te_target.language = "C";
te_target.c2cplusplus_linkage_begin = "#ifdef\t__cplusplus\nextern\t&quot;C&quot;\t{\n#endif";
te_target.c2cplusplus_linkage_end = "#ifdef\t__cplusplus\n}\n#endif";
te_target.main = "main";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("cf01ff46-666f-48ca-adfc-b3be3773eee0",
	"e99993d4-5add-4567-8eac-dc1566a17bf6",
	'te_target',
	"1a42f48f-6b7e-4a25-999f-5865842990eb",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("1a42f48f-6b7e-4a25-999f-5865842990eb",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<target>',
	'',
	'',
	'../../ooaofooa/Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("e99993d4-5add-4567-8eac-dc1566a17bf6",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("1c2f2563-ab57-4c40-bdc4-d67d59ec8ce1",
	"00000000-0000-0000-0000-000000000000",
	'sys_singletons',
	'',
	'//
create object instance te_prefix of TE_PREFIX;
::prefix_factory( te_prefix:te_prefix );
create object instance te_typemap of TE_TYPEMAP;
::typemap_factory( te_typemap:te_typemap );
create object instance te_container of TE_CONTAINER;
::container_factory( te_container:te_container );
create object instance te_copyright of TE_COPYRIGHT;
::copyright_factory( te_copyright:te_copyright );
create object instance te_dlist of TE_DLIST;
::dlist_factory( te_dlist:te_dlist );
create object instance te_dma of TE_DMA;
::dma_factory( te_dma:te_dma );
create object instance te_eq of TE_EQ;
::eq_factory( te_eq:te_eq );
create object instance te_file of TE_FILE;
::file_factory( te_file:te_file );
create object instance te_instance of TE_INSTANCE;
::instance_factory( te_instance:te_instance );
create object instance te_ilb of TE_ILB;
::ilb_factory( te_ilb:te_ilb );
create object instance te_persist of TE_PERSIST;
::persist_factory( te_persist:te_persist );
create object instance te_relinfo of TE_RELINFO;
::relinfo_factory( te_relinfo:te_relinfo );
create object instance te_relstore of TE_RELSTORE;
::relstore_factory( te_relstore:te_relstore );
create object instance te_set of TE_SET;
::set_factory( te_set:te_set );
create object instance te_slist of TE_SLIST;
::slist_factory( te_slist:te_slist );
create object instance te_string of TE_STRING;
::string_factory( te_string:te_string );
create object instance te_thread of TE_THREAD;
::thread_factory( te_thread:te_thread );
create object instance te_tim of TE_TIM;
::tim_factory( te_tim:te_tim );
create object instance te_callout of TE_CALLOUT;
::callout_factory( te_callout:te_callout );
create object instance te_trace of TE_TRACE;
::trace_factory( te_trace:te_trace );
create object instance te_extent of TE_EXTENT;
::extent_factory( te_extent:te_extent );
create object instance te_target of TE_TARGET;
::target_factory( te_target:te_target );
//
create object instance te_assign of TE_ASSIGN;
create object instance te_create_instance of TE_CREATE_INSTANCE;
create object instance te_for of TE_FOR;
create object instance te_if of TE_IF;
create object instance te_while of TE_WHILE;
create object instance te_elif of TE_ELIF;
create object instance te_delete_instance of TE_DELETE_INSTANCE;
create object instance te_create_event of TE_CREATE_EVENT;
create object instance te_relate of TE_RELATE;
create object instance te_relate_using of TE_RELATE_USING;
create object instance te_unrelate of TE_UNRELATE;
create object instance te_unrelate_using of TE_UNRELATE_USING;
create object instance te_select of TE_SELECT;
create object instance te_select_where of TE_SELECT_WHERE;
create object instance te_generate_precreated_event of TE_GENERATE_PRECREATED_EVENT;
create object instance te_event_parameters of TE_EVENT_PARAMETERS;
create object instance te_generate of TE_GENERATE;
create object instance te_generate_creator_event of TE_GENERATE_CREATOR_EVENT;
create object instance te_generate_to_class of TE_GENERATE_TO_CLASS;
create object instance te_sgn of TE_SGN;
create object instance te_iop of TE_IOP;
create object instance te_operation of TE_OPERATION;
create object instance te_bridge of TE_BRIDGE;
create object instance te_function of TE_FUNCTION;
create object instance te_return of TE_RETURN;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO PE_PE
	VALUES ("1c2f2563-ab57-4c40-bdc4-d67d59ec8ce1",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("f2bb5b36-edb8-4b10-ae00-49a08eeee5af",
	"00000000-0000-0000-0000-000000000000",
	'a1',
	'',
	'// Translate the OAL.
::val_translate();
::oal_translate();
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO PE_PE
	VALUES ("f2bb5b36-edb8-4b10-ae00-49a08eeee5af",
	1,
	"92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO PE_PE
	VALUES ("92ad83ae-9fba-40f1-bf46-bdbe8834ae74",
	1,
	"f76021f0-a257-44e3-a11e-4104b91c38ec",
	"00000000-0000-0000-0000-000000000000",
	7);
INSERT INTO EP_PKG_PROXY
	VALUES ("f76021f0-a257-44e3-a11e-4104b91c38ec",
	"d9bc5487-4193-4817-be1c-6c3f3339aebf",
	"d9bc5487-4193-4817-be1c-6c3f3339aebf",
	'mcmc',
	'',
	0,
	'../mcmc.xtuml');
INSERT INTO S_SYS_PROXY
	VALUES ("d9bc5487-4193-4817-be1c-6c3f3339aebf",
	'escher',
	1,
	'../../escher.xtuml');
